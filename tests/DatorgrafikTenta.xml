<?xml version="1.0" encoding="utf-8" ?>
<Test Name="Tenta">
	<TestQuestion Category="Mathematics">
		<Question>
			Vad är definitionen av ett vektor rum av dimension [math]d[/math]?
		</Question>
		<Answer>
			Det är mängden av alla (ordnade) [math]d[/math]-tuplar, som uppfyller två egenskaper:
			[math]bar(x)+bar(y) in RR^d, lambda bar(x) in RR^d, x, y in RR^d, lambda in RR[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Mathematics">
		<Question>
			Hur definieras punkter och vektorer i homogena koordinater?
		</Question>
		<Answer>
			Punkter: [math][[x, y, z, w]], w != 0[/math].
			Vektorer: [math][[x, y, z, 0]][/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Mathematics">
		<Question>
			Ange hur standard transformationer ser ut i homogena koordinater.
		</Question>
		<Answer>
			[b]Translation[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((1, 0, 0, Delta X), (0, 1, 0, Delta Y), (0, 0, 1, Delta Z), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]

			[b]Skalning[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((S_X, 0, 0, 0), (0, S_Y, 0, 0), (0, 0, S_Z, 0), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]

			[b]Rotation runt X-axeln[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((1, 0, 0, 0), (0, cos \theta, -sin \theta, 0), (0, sin \theta, cos \theta, 0), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]

			[b]Rotation runt Y-axeln[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((cos \theta, 0, sin \theta, 0), (0, 1, 0, 0), (-sin \theta, 0, cos \theta, 0), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]

			[b]Rotation runt Z-axeln[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((cos \theta, -sin \theta, 0, 0), (sin \theta, cos \theta, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]

			[b]Spegling i XY planet[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((1, 0, 0, 0), (0, 1, 0, 0), (0, 0, -1, 0), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grids">
		<Question>
			Ange definitionen av hörn, linje, face, voxel för grids.
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/Grids.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grids">
		<Question>
			Ange olika typer av grids.
		</Question>
		<Answer>
			[ul]
				[li]Structured grids: hur celler hänger ihop är implicit given.[/li]
				[li]Unstructured grids: hur celler hänger ihop är explicit given.[/li]
				[li]Hybrid grids: kombination av olika typer av grids.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grids">
		<Question>
			Vad är "structured grid"?
		</Question>
		<Answer>
			Det finns tre olika typer av structured grids:
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/StructuredGrids.png[/img].

			Om vi låter antalet hörn i varje dimension vara [math]D_x, D_y, D_z[/math], så ges antalet celler av: [math](D_x - 1) * (D_y - 1) * (D_z - 1)[/math].

			[b]Uniform grid[/b]
			Alla celler är rektanglar/rätblock av samma storlek, alla linjer för rutnätet är parallella till axelarna. Vi låter också storlekarna för cellerna vara: [math]d_x, d_y, d_z[/math]. För att hitta en cell givet en koordinat är mycket effektivt och lätt.

			För att definiera ett uniform grid behöver vi:
			[ul]
				[li]Bounding box: [math](x_text(min), y_text(min), z_text(min)), (x_text(max), y_text(max), z_text(max))[/math][/li]
				[li]Antalet celler i varje dimension: [math]D_x, D_y, D_z[/math].[/li]
			[/ul][b]Rectilinear grids[/b]
			I det här fallet så kan celler vara av olika stora, men alla linjer i rutnätet är fortfarande parallella till axelarna. För att hitta cell givet en koordinat är relativt lätt.

			[b]Curvilinear grids[/b]
			I det här fallet så är celler quadrilaterals, och linjer i rutnätet behöver ej vara parallella. För att hitta en cell givet en koordinat behöver vi i det lokala fallet kolla via senaste cellen eller dess grannar. I det globala fallet behöver vi använda oss av quadtree/octree.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grids">
		<Question>
			Vad är ett cartesian grid?
		</Question>
		<Answer>
			Det är ett specialfall av uniform grid när [math]d_x = d_y = d_z[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grids">
		<Question>
			Vad är "unstructured grid"?
		</Question>
		<Answer>
			Här är positionen för hörn och hur dessa är sammankopplade explicit given. Linjär interpolering sker m.h.a barycentriska koordinater i en triangel. För att hitta cell givet en koordinat behöver vi i det lokala fallet kolla via senaste triangel eller dess grannar. I det globala fallet behöver vi använda oss av quadtree/octree.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grids">
		<Question>
			Ange olika sätt för att lagra "unstructured grids".
		</Question>
		<Answer>
			[b]Face set[/b]
			Spara "faces" för varje triangel, vilket består av tre positioner (hörnen). Detta spara inte hur hörnen är sammankopplade. Detta är en mycket simpel struktur, men dock är opraktiskt i praktiken.

			[b]Shared vertex[/b]
			Vi har två tabeller, en för hörn/positioner "vertex table" och en annan för trianglar "triangle table", vilket indikerar vilka hörn som triangeln består av. Detta spara inte hur hörnen är sammankopplade. Detta är ganska enkel och effektiv, och möjliggör effektiva operationer på statiska modeller. Exempel är OFF, OBJ, PLY.

			[b]Face-based connectivity[/b]
			Hörnen sparar: position och referens till face. Face sparar referenser till tre hörn, och referenser till tre grannar.

			[b]Edge-based connectivity[/b]
			Hörnen sparar: position och referens till en kant. Kanter sparar två referenser till hörn, två till face och fyra till kanter. Face sparar en referens till edge.

			[b]Half-edge based connectivity[/b]
			Hörn sparar: position och referens till en halv-kant. Halv-kanter sparar en referens till hörn, en till face, och 1, 2, eller 3 referenser till halv-kanter. Face sparar en referens till en halv-kant.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Interpolation">
		<Question>
			Hur fungerar "Nearest-Neighbor interpolation"?
		</Question>
		<Answer>
			Tilldela värdet för en punkt till värdet för den närmaste punkten.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Interpolation">
		<Question>
			Hur fungerar linjär interpolation (i 1D)?
		</Question>
		<Answer>
			I det generella fallet ges det av: [math]f(x) = (x_1 - x) / (x_1 - x_0) f(x_0) + (x - x_0) / (x_1 - x_0) f(x_1), x in [x_0, x_1][/math].

			Men det är vanligt med följande specialfall: [math]f(x) = (1 - x) f(0) + x f(1), x in [0, 1][/math]. Det går också att uttrycka det som: [math]text(bas) xx text(koefficienter) = [[1-x, x]] [[f(0)], [f(1)]] = [[1, x]] [[1, 0], [-1, 1]] [[f(0)], [f(1)]][/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Interpolation">
		<Question>
		Hur fungear linjär interpolation (i 2D), även kallat för bilinjär interpolation?
		</Question>
		<Answer>
			Det fungerar så att vi först interpolerar två gånger i x riktningen, och sedan en gång i y riktningen. Det går också att göra omvänt, två gånger i y och en gång i x.

			Formelen ges av: [math]f(x, y) = (1-y) ((1-x) f_(00) + x f_(10)) + y ((1-x) f_(01) + x f_(11))[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Interpolation">
		<Question>
			Hur fungerar linjär interpolation (i 3D), även kallat för trilinjär interpolation?
		</Question>
		<Answer>
			Det fungerar så att vi först interpolerar fyra gånger i x riktningen, och sedan två gånger i y riktningen och slutligen en gång i z riktningen.

			Formelen ges av: [math]f(x, y, z) = sum_(k=0)^p sum_(j=0)^m sum_(i=0)^n b_i(x) b_j(y) b_k(z) f_(ijk)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Interpolation">
		<Question>
			Hur lyder derivatan för en bilinjär interpolation?
		</Question>
		<Answer>
			[math](del f(x, y)) / (del x) = (f_(10) - f_(00)) (1 - y) + (f_(11) + f_(01)) y[/math]
			[math](del f(x, y)) / (del y) = (f_(10) - f_(00)) (1 - x) + (f_(11) + f_(01)) x[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Interpolation">
		<Question>
			Vad för problem finns det med att använda en explicit formel för derivering av interpolation?
		</Question>
		<Answer>
			Problemet är att denna derivata är diskontinuerlig vid ändpunkterna. Man kan lösa detta genom antigen att använda en högre ordning på interpolation (kubisk) eller använda sig av numerisk derivata.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Interpolation">
		<Question>
			Hur lyder numerisk derivata för interpolation?
		</Question>
		<Answer>
			[math](df(x_i)) / (dx) ~~ (f(x_(i+1)) - f(x_(i-1))) / (2h)[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Interpolation">
		<Question>
			Vad är barycentriska koordinater för något?
		</Question>
		<Answer>
			Det är ett sätt att uttrycka koordinaterna för en punkt [math]bar(p)[/math] som ligger i en triangel [math]bar(p)_1, bar(p)_2, bar(p)_3[/math].

			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/BarycentricCoordinates.png[/img]

			Då ges punkten [math]bar(p)[/math] av [math]bar(p)=alpha bar(p)_1 + beta bar(p)_2 + gamma bar(p)_3[/math]. Då är [math]alpha, beta, gamma[/math] punktens barycentriska koordinater, som uppfyller [math]alpha + beta + gamma = 1[/math].

			För att hitta koordinaterna, så kan man beräkna arean för de olika trianglarna:[math]alpha = (area(Delta(bar(p)_2, bar(p)_3, bar(p)))) / (area(Delta(bar(p)_1, bar(p)_2, bar(p)_3))), beta = (area(Delta(bar(p)_1, bar(p)_3, bar(p)))) / (area(Delta(bar(p)_1, bar(p)_2, bar(p)_3))), gamma = (area(Delta(bar(p)_1, bar(p)_2, bar(p)))) / (area(Delta(bar(p)_1, bar(p)_2, bar(p)_3)))[/math].

			Det går även att lösa ekvationssystemet: [math][[x_0, x_1, x_2], [y_0, y_1, y_2], [1, 1, 1]] [[alpha], [beta], [gamma]] = [[x], [y], [1]][/math].

			Explicit lösningar ges av:
			[math]alpha = 1 / (2A) det([[x, x_2, x_3], [y, y_2, y_3], [1, 1, 1]])[/math]
			[math]beta = 1 / (2A) det([[x_1, x, x_3], [y_1, y, y_3], [1, 1, 1]])[/math]
			[math]gamma = 1 / (2A) det([[x_1, x_2, x], [y_1, y_2, y], [1, 1, 1]])[/math]
			[math]A = 1 / 2 det([[x_1, x_2, x_3], [y_1, y_2, y_3], [1, 1, 1]])[/math].
		</Answer>
	</TestQuestion>
		<TestQuestion Category="Interpolation">
		<Question>
			Hur fungerar linjär interpolation i en triangel?
		</Question>
		<Answer>
			Givet triangelns tre hörn [math]f_0, f_1, f_2[/math], så kan interpolationen skrivas som [math]f(x, y) = a + bx + cy[/math], där koefficienterna fås genom att lösa följande ekvationssystem: [math][[1, x_0, y_0], [1, x_1, y_1], [1, x_2, y_2]] [[a], [b], [c]] = [[f_0], [f_1], [f_2]][/math].

			Det går även att använda sig av barycentriska koordinater: [math]f(x, y) = alpha(x, y) f_0 + beta(x, y) f_1 + gamma(x, y) f_2[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad är B-spline?
		</Question>
		<Answer>
			Givet [math]n+1[/math] kontrollpunkter [math]bb "P"_0, bb "P"_1, ..., bb "P"_n[/math] och "knut" vektor [math]U = { u_0, u_1, ..., u_m }[/math] så är en B-spline kurva av grad [math]p[/math] definierad som [math]C(u) = sum_(i=0)^n N_(i, p)(u) bb "P"_i[/math] där [math]N_(i, p)(u)[/math] är basfunktioner av grad [math]p[/math]. Vi har även att [math]m = n + p + 1[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Hur fungerar De Casteljau algoritm?
		</Question>
		<Answer>
			Först, De Casteljau algoritm beräknar en Bezier kurva för ett givet antal kontrollpunkter.
			Antag att [math]bb "b"_0, bb "b"_1, ... bb "b"_n in RR^d[/math] är kontrollpunkterna, och kurvan som vi vill ha är [math]bb "x"(t), t in [0, 1][/math].

			Låt [math]b_i^r(t)[/math] vara en koefficient, och dessa beräknas som: [math]bb "b"_i^(r)(t) = (1-t) bb "b"_i^((r-1)) + t bb "b"_(i+1)^((r-1))[/math], med [math]bb "b"_i^(0)=bb "b"_i[/math]. Då gess slutligen [math]bb "x"(t) = bb "b"_0^((n))[/math].

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/DeCasteljauAlgorithm.png[/img]

			Polygonet som består av punkterna [math]bb "b"_0, bb "b"_1, ... bb "b"_n[/math] kallas för Bezier polygonet.

			[b]Egenskaper[/b]
			[ul]
				[li]Bezier kurvan är ett polynom av grad [math]n[/math][/li]
				[li]Endast slutpunkterna som interpoleras: [math]x(0)=bb "b"_0, x(1)=bb "b"_n[/math], övriga punkter approximeras.[/li]
				[li]Konvext hölje: Bezier kurvan ligger innanför det konvexa höljet av Bezier polygonet.[/li]
				[li]Tid: [math]O(n^2)[/math], minne: [math]O(n)[/math].[/li]
				[li]Variation diminishing: ingen linje skär Bezier kurvan mer än Bezier polygonet för linjen.[/li]
				[li]Förflyttning av en kontrollpunkt förändrar hela kurvan.[/li]
				[li]Invariant under affine transformation.[/li]
				[li]Invariant under barycentriska kombinationer.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Hur kan man beräkna derivatan av Bezier kurvor?
		</Question>
		<Answer>
			Första derivatan:
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/BezierCurveFirstDerivative.png[/img]

			Andra derivatan:
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/BezierCurveSecondDerivative.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad är en Bernstein bas?
		</Question>
		<Answer>
			Det är ett sätt att algebraiskt definiera Bezier kurvor. Låt [math]B = { B_0^((n)), B_1^((n)), B_0^((n)) ..., B_n^((n)) }[/math] vara en Bernstein bas av grad [math]n[/math]. Då ges kurvan av: [math]bb "x"(t) = sum_(i=0)^n B_i^((n))(t) bb "p"_i[/math] där [math]bb "p"_i[/math] är kontrollpunkter.

			En Bernstein bas an bestämmas av: [math]B_i^((n))(t) = text(binomialkoefficient)(n, i) t^i (1-t)^(n-1)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad är en Bezier Spline?
		</Question>
		<Answer>
			Det innebär att vi sätter ihop flera olika Bezier kurvor för att bilda en kurva. Givet två kurvor [math]bb "x"_1(s) s in [t_0, t_1][/math] och [math]bb "x"_2(s) s in [t_1, t_2][/math]. [math]bb "x"_1(s)[/math] och [math]bb "x"_2(s)[/math] säges vara [math]C^r[/math] kontinuerlig i [math]t_1[/math] om de sammanfaller i 0:te till [math]r[/math]:te derivatan av [math]t_1[/math].

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/SplineContinuity.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad är skillnaden mellan [math]C^r[/math] och [math]G^r[/math] kontinuerlighet?
		</Question>
		<Answer>
			[math]C^r[/math] betyder att parametriseringen är kontinuerlig medans [math]G^r[/math] att endast att kurvan i sig själv är kontinuerlig. [math]G^r[/math] är ett svagare krav än [math]C^r[/math], men är lättare att uppnå.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad för krav ställer vi på en [math]C_0[/math] kontinuerlig Bezier spline?
		</Question>
		<Answer>
			För varje spline segment så interpolerar första och sista kontrollpunkten. Detta innebär att punkter i närliggande segment måste sammanfalla.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad för krav ställer vi på en [math]C_1[/math] kontinuerlig Bezier spline?
		</Question>
		<Answer>
			Samma sak som för [math]C_0[/math] och: tangenta vektorer proportionerlig emot skillnaden [math]bb "p"_1 - bb "p"_0, bb "p"_n - bb "p"_(n-1)[/math]. Detta innebär att dessa vektorer måste vara identiska.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Hur fungerar Bezier ytor?
		</Question>
		<Answer>
			Det fungerar på samma sätt som Bezier kurvor, fast vi använder oss av bilinjär interpolation istället. Detta kallas även för "Tensor Product Bezier Surfaces".

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/BezierSurface.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad är "Tensor Product Surfaces"?
		</Question>
		<Answer>
			Det kan ses som en kurva av kurvor, där varje "patch" består av rektanglar (quads). Om vi låter [math]bb "b"_i, bb "b"_j[/math] vara två kurvor, så ges ytan av: [math]bb "f"(u, v) = sum_(i=1)^n sum_(j=1)^n bb "b"_i(u) bb "b"_j(v) bb "p"_(i, j)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad är "Beizer Patches"?
		</Question>
		<Answer>
			Kurvan för gränser är en Bezier kurva av gränspunkterna?
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad är "Total Degree Surfaces"?
		</Question>
		<Answer>
			Vi använder oss av trianglar istället. Detta kan konstrueras med barycentriska koordinater.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/TotalDegreeSurface.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad för problem finns det med spline patches?
		</Question>
		<Answer>
			[ul]
				[li]En kontinuerlig tensor product spline är endast definierad för ett rutnät av quads. Detta innebär att topologin av objektet är begränsad.[/li]
				[li]Det är svårt att få en yta med flera variabler kontinuerlig, på grund av de många begräsningarna som detta ställer.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad innebär "subdivision surfaces"?
		</Question>
		<Answer>
			Det innebär att given en yta, så delar vi varje patch till t.ex. fyra nya patches, som vi sedan interpolerar för att få en slät yta. Det består av tre steg:
			[ol]
				[li]Dela nuvarande mesh (subdivide).[/li]
				[li]Skapa linjärt interpolerade punkter (splitting).[/li]
				[li]Flytta på punkter m.h.a. viktat medelvärde (average).[/li]
			[/ol]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Hur fungerar Chaikins Corner Cutting Splines?
		</Question>
		<Answer>
			[ol]
				[li]Dela varje linjesegment på mitten.[/li]
				[li]Beräkna ny punkt som medelvärdet mellan punkten och dess nästa granne (klockvis).[/li]
				[li]Upprepa.[/li]
			[/ol]Konvergerar emot en kvadratisk B-Spline kurva.

			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/ChaikinsCornerCuttingSpline.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Hur fungerar Chaikins Corner Cutting?
		</Question>
		<Answer>
			Vi beräknar de nya punkterna som: [math]Q_(2i) = 3/4 P_i + 1/4 P_(i+1), Q_(2i+1) = 1/4 P_i + 3/4 P_(i+1)[/math]. Detta leder till en kurva när antalet punkter går oändligheten som är [math]C_1[/math] kontinuerlig överallt.

			Exempel: Antag att vi har fyra punkter, [math]P_0, P_1, P_2, P_3[/math], då gess de nya punkterna av:
			[math]Q_0 = 3/4 P_0 + 1/4 P_1, Q_1 = 1/4 P_0 + 3/4 P_1[/math]
			[math]Q_2 = 3/4 P_1 + 1/4 P_2, Q_3 = 1/4 P_1 + 3/4 P_2[/math]
			[math]Q_4 = 3/4 P_2 + 1/4 + P_3, Q_5 = 1/4 P_2 + 3/4 P_3[/math].

			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/ChaikinsCornerCutting.png[/img]

			Det går även att uttrycka det som:
			[math]P_(2i)^(k+1)=3/4 P_i^k + 1/4 P_(i+1)^k,  P_(2i+1)
			^(k+1)=1/4 P_i^K + 3/4 P_(i+1)^k[/math], där [math]k[/math] anger generationen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Hur fungerar "cubic subdivision"?
		</Question>
		<Answer>
			[math]P_(2i)^(k+1)=1/8 (P_(i-1)^k + 6 P_i^k + P_(i+1)^k)[/math]
			[math]P_(2i+1)^(k+1)=1/8 (4P_(i)^k + 4 P_(i+1)^k)[/math]

			När antalet punkter går emot oändligheten så går kurvan emot en [math]C_2[/math] kontinuerlig kurva.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Hur lyder den generella formeln för B-spline subdivision?
		</Question>
		<Answer>
			[ul]
				[li]Dela linjer som vanligt: sätt in punkter i mitten av linjen.[/li]
				[li]Viktat medelvärde: [math]1/(2^(d-1)) (text(binomialkoefficient)(d-1, 0), text(binomialkoefficient)(d-1,1), ..., text(binomialkoefficient)(d-1, d-1))[/math] för en B-spline av grad [math]d[/math].[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Vad är "limit mask"?
		</Question>
		<Answer>
			Det är sätt att beräkna positionen för subdivision punkterna direkt istället (med gränsvärde) för att approximera detta med många iterationer.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="GeometricModeling">
		<Question>
			Hur fungerar "Tensor Product B-Spline Subdivision Surfaces"?
		</Question>
		<Answer>
			[ul]
				[li]Börja med en vanlig quad mesh.[/li]
				[li]
					Vid varje subdivision steg:
					[ul]
						[li]Dela varje quad i fyra delar (quadtree subdivision)[/li]
						[li]Placera linjärt interpolerade hörn.[/li]
						[li]Applicera en 2D averaging mask.[/li]
					[/ul]
				[/li]
			[/ul]Exempel på averaging masks är:
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/AveragingMasks.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Ange olika photoreceptors.
		</Question>
		<Answer>
			Dessa är binära, de kan antigen vara på eller av. Informationen förmedlas av vilka celler som är aktiva och för hur länge dessa är aktiva.
			[ul]
				[li]Cones: för syn i ljuset.[/li]
				[li]Rods: för syn i mörkret.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Ange olika "cones" för koda färg.
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/ColorCones.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Inom vilket intervall är det synliga ljuset?
		</Question>
		<Answer>
			Inom intervallet 380-780 nm.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/Wavelengths.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Vad innebär färg?
		</Question>
		<Answer>
			[ul]
				[li]En spektralfördelning av ljuset.[/li]
				[li]En perceptuell respons till en spektralfördelning av ljuset.[/li]
				[li]Ett sätt att koda spektralfördelning av ljuset.[/li]
			[/ul]Notera att färg beskrivs ej som en specifik våglängd eller RGB.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Vad innebär additiv färg blandning?
		</Question>
		<Answer>
			Det innebär att ljus med olika spektralfördelningar kommer samman, och dessa läggs ihop. Detta resulterar i en ny fördelning av ljuset (färg). Exempel är RGB.
			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/RGB.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Vad innebär subtraktiv färg blandning?
		</Question>
		<Answer>
			En ljusstråle med ett vit spektrum av ljus träffar en yta, som reflekterar ljuset. Ytan absorberar en viss våglängd av ljuset, vilket resulterar i en annan fördelning av ljuset (färg). Exempel är CMY(K).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Hur fungerar CMY(K)?
		</Question>
		<Answer>
			Består av:
			[ul]
				[li]Turkos (cyan): komplement av röd (innebär att den absorberar rött).[/li]
				[li]Magenta: komplement av grön.[/li]
				[li]Gul: komplement av blå.[/li]
				[li]K: svart. Används för att gömma imperfektioner som uppstod vid blandningen.[/li]
			[/ul][img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/CMYK.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Hur fungerar HLS?
		</Question>
		<Answer>
			Består av:
			[ul]
				[li]Hue: färgen (röd, grön, blå, etc.), beskrivs av en vinkel.[/li]
				[li]Lightness: anger hur mycket ljus.[/li]
				[li]Saturation: beskriver hur mycket av färgen som är grå.[/li]
			[/ul][img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/HLS.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Hur fungerar HSV?
		</Question>
		<Answer>
			Består av:
			[ul]
				[li]Hue: färgen (röd, grön, blå, etc.), beskrivs av en vinkel.[/li]
				[li]Saturation: beskriver hur mycket av färgen som är grå.[/li]
				[li]Value: anger hur mycket ljus.[/li]
			[/ul][img width="25%" height="25%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/HSV.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Color">
		<Question>
			Vad är huvudsakliga skillnaden mellan RGB och HSV/HLS?
		</Question>
		<Answer>
			RGB är teknisk orienterat färgsystem, som är inte baserat på hur människor uppfattar färger, vilket HSV/HLS är.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="PerspectiveGeometry">
		<Question>
			Vad är en "pinhole" kamera för något?
		</Question>
		<Answer>
			Det är den enklaste typen av avbildningsenhet som fångar in geometrin av en perspektiv projektion. Det fungerar så att ljuset kommer in i kameran genom en öppning som är oändligt liten. Skärningen mellan ljusstrålen och bildplanet bildar avbildningen av objektet.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/PinholeCamera.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="PerspectiveGeometry">
		<Question>
			Ange relationer och ekvationer för "pinhole" kamera.
		</Question>
		<Answer>
			Vi har först:
			[math]x / f = X / Z, y / f = Y / Z[/math].

			Antag att [math]alpha[/math] är vyvinkeln och [math]h[/math] storleken av skärmen
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/PerspectiveGeometry1.png[/img]
			Då gäller: [math]tan (alpha / 2) = h / (2f)[/math].

			Vi har om [math]h[/math] och [math]f[/math] skalas av en gemensam faktor, så förändrar sig ej [math]alpha[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="PerspectiveGeometry">
		<Question>
			Vad är en "view volume"?
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/ViewVolume.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="PerspectiveGeometry">
		<Question>
			Hur lyder matrisen för att omvandla pixel i världen till skärmen?
		</Question>
		<Answer>
			Den ges av [math]P_S = S N P[/math].

			[math]S[/math]: skala till pixlar, origo uppe i högra hörnet.
			[math]S = [[w/2, 0, 0, w/2], [0, -h/2, 0, h/2], [0, 0, 1, 0], [0, 0, 0, 1]][/math]

			[math]N[/math]: normalisera till koordinater på skärmen.
			[math]N = [[1 / ((w/h) tan(alpha/2)), 0, 0, 0], [0, 1 / (tan(alpha/2)), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]][/math].

			[math]P[/math] projektionsmatris med [math]f = 1[/math].
			[math]P = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, -1], [0, 0, 1, 0]][/math].

			Notera att med denna matris så får vi fokuspunkten vid origo, vy riktningen som Z-axeln. Vill vi ändra positionen och vy riktningen så kan vi multiplicera [math]P_S[/math] med en transformation.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad innebär rasterization?
		</Question>
		<Answer>
			[ul]
				[li]Projicera alla trianglar till skärmen.[/li]
				[li]Omvandla till pixlar (rasterize).[/li]
				[li]Avgör vilka pixlar som är synliga.[/li]
				[li]Applicera shading (beräkna färg).[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad är "Painters" algoritm för något?
		</Question>
		<Answer>
			Det är en algoritm för att avgöra vilka pixlar som ska synas. Den fungerar så att vi först sorterar alla trianglar bakåt-till-framåt (i den ordning som de ska synas på skrämen). Sedan så ritar vi trianglarna där vi tillåter att pixlar skrivs över.

			Nackdelarna med denna algoritm är att den är seg ([math]O(n log n)[/math] för [math]n[/math] antal trianglar), och den fungerar inte alltid (se bild). För att undvika detta problem så behöver vi på något sätt beskära trianglarna.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/PainterAlgorithm.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad är "z-Buffer" algoritm för något?
		</Question>
		<Answer>
			Det är en algoritm för att avgöra vilka pixlar som ska synas. Den fungerar så att för varje pixel så sparar vi ett djup, som börjar med värdet [math]\infty[/math]. Vi ritar sedan ut alla trianglar, och beräknar djupet. Om djupet för pixeln är större än nuvarande, så skriver vi ej över pixeln.

			[img width="25%" height="25%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/ZBuffer.png[/img]

			[b]Fördelar[/b]
			[ul]
				[li]Mycket simpel.[/li]
				[li]Mångsidig - kräver endast att objektet kan ritas ut.[/li]
				[li]Mycket snabb.[/li]
			[/ul][b]Nackdelar[/b]
			[ul]
				[li]Kräver extra minne.[/li]
				[li]Endast lika hög upplösning som en pixel - Painters algoritm kan krävas för vissa vektorgrafik beräkningar.[/li]
				[li]Stödjer ej transparens - löses med antigen sortering eller A-buffer (ej stöd i hårdvaran).[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Ange olika strategier för att hantera "clipping".
		</Question>
		<Answer>
			[b]Förkasta pixlar[/b]
			Om en pixel inte är på skärmen, rendera ej. Problemen med detta är att det är mycket segt.

			[b]Screen space clipping[/b]
			Modifiera rasterize till att hoppa till synliga pixlar. Detta är effektivt, men finns problem mär pixeln korsar kameras plan.

			[b]View Frustum Clipping[/b]

			[b]View Frustum Culling[/b]
			Förkasta trianglar som ej är innan för "view frustum" (dvs det som kameran ser).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Ange olika modeller för hantera hur ljus reflekteras.
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/Reflectance.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur fungerar en enkel modell för shading?
		</Question>
		<Answer>
			Vi har en ljuskälla som vi ser som en punkt. Definiera:
			[ul]
				[li]Ljusvektorn - [math]l = text(pos)_text(light) - text(pos)_text(object)[/math].[/li]
				[li]Vy vektorn - [math]v = text(pos)_text(camera) - text(pos)_text(object)[/math].[/li]
				[li]Normalen för ytan - [math]n[/math].[/li]
			[/ul]Om vi vill utöka till flera ljuskällor, så summerar vi bidraget från alla källor.
			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/LightModel.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur fungerar "diffuse" ytor (även kallat för Lambertian ytor)?
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/DiffuseLightning.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad innebär "diffuse" reflektion?
		</Question>
		<Answer>
			Det innebär att ytan är grov, vilket gör att inkommande ljus spridds likformigt.
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/DiffuseReflection.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur kan man bestämma normalen för en triangel?
		</Question>
		<Answer>
			Den ges av [math](bb "p"_2 - bb "p"_1) xx (bb "p"_3 - bb "p"_1)[/math].
			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/TriangleNormal.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur kan man bestämma normalen för ett hörn?
		</Question>
		<Answer>
			Som ett medelvärde av närliggande trianglar.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad är "ambient" reflektion?
		</Question>
		<Answer>
			Detta innebär att vi adderar en konstant till färgen: [math]c = c_text(surface) @ c_text(ambient light)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad innebär en perfekt reflektion?
		</Question>
		<Answer>
			Detta innebär att ljuset reflekteras perfekt på ytan: [math]r = 2 (: n, l :) n - l[/math].
			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/PerfectReflection.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur fungerar Phong ljusmodell?
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/PhongModel.png[/img]

			Den är dock fysisk inkorrekt (energin bevaras ej) och gör att objekten ser plastiga ut.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur fungerar Blinn-Phong modell?
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/BlinnPhongModel.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad innebär alpha blending?
		</Question>
		<Answer>
			Det är ett sätt för att hantera transparens, och för att blanda två olika färger: [math]c = alpha c_text(front) + (1 - alpha) c_text(back)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad innebär "refraction"?
		</Question>
		<Answer>
			Att ljusstrålar byter riktningar när den byter medium.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad är Snells lag (för refraction)?
		</Question>
		<Answer>
			[math]sin(theta_1) / sin(theta_2) = n_2 / n_1[/math].
			[img width="25%" height="25%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/SnellsLaw.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad är skillnaden mellan reflektion och refraction?
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/ReflectionVsRefraction.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Ange olika typer av flat shading.
		</Question>
		<Answer>
			[ul]
				[li]Gouraud Shading: beräkna färg för varje hörn, interpolera färg för pixlar.[/li]
				[li]Phong Shading: interpolera normal för varje pixel.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur fungerar raytracing?
		</Question>
		<Answer>
			Vi börjar i kameran (viewing point), och sedan följer vi ljusstrålarna i bakåtriktning, och hanterar hur den reflekteras, etc. vid objekten.

			Vi har då:
			[ul]
				[li]Primary rays: strålar genom en pixel.[/li]
				[li]Shadow rays: strålar som blockeras (hard shadows).[/li]
				[li]Reflection: reflektera strålar längs normalen vid skärningspunkten.[/li]
			[/ul][img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/RecursiveRaytracing.png[/img]

			För att hantera flera strålar, så använder vi oss av rekursion. Detta leder till att raytracing blir mycket ineffektivt att beräkna: [math]O(n * m * 2^r)[/math] där [math]n = text(antalet trianglar), m = text(antalet pixlar), r = text(max djup av rekursion)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur kan vi avgöra om en stråle skär ett plan?
		</Question>
		<Answer>
			En punkt på ett plan uppfyller: [math](bb "p" - bb "p"_0) * bb "n" = 0[/math] och en punkt på en ståle uppfyller [math]bb "p" = bb "p"_r + lambda bb "t"_r, lambda >= 0[/math]. Vi brukar då begränsa [math]lambda le lambda_text(max)[/math].

			För att avgöra beräknar vi då: [math]lambda = ((bb "p"_0 - bb "p"_r) * n) / (bb "t"_r * n)[/math]. Strålen skär planet om [math](bb "t"_r * n) != 0[/math] och [math]lambda in [0, lambda_text(max)][/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur kan vi avgöra om en stråle skär en triangel?
		</Question>
		<Answer>
			Beräkna [math]bb "t"_1 = bb "p"_1 - bb "p"_0, bb "t"_2 = bb "p"_2 - bb "p"_0[/math]. Detta ger att normalen för triangeln blir: [math]bb "n" = bb "t"_1 xx bb "t"_2[/math]. Vi kollar sedan om strålen skär planet som spänns upp av denna normal. När vi vet att den skär planet, så måste vi kolla om skärningen sker inom triangeln. Detta gör vi genom att beräkna skärningspunkten, och kolla att den ligger inom triangeln (t.ex. med barycentriska koordinater).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur kan vi avgöra om en stråle skär en sfär?
		</Question>
		<Answer>
			Vi har sfärens ekvation: [math](: bb "x" - bb "c", bb "x" - bb "c" :) = r^2[/math] och strålens ekvation: [math]bb "x" = bb "p"_r + lambda bb "t"_r[/math]. Sätter vi in strålens ekvation i sfärens får vi: [math](: bb "p"_r + lambda bb "t"_r - bb "c", bb "p"_r + lambda bb "t"_r - bb "c" :) - r^2 = 0[/math]. Detta resulterar i följande ekvation: [math]lambda^2 bb "t"_r^2 + 2 lambda (bb "t"_r * (bb "p"_r - bb "c")) + (bb "p"_r - bb "c")^2 - r^2 = 0[/math]. Löser vi denna får vi skärningen. Giltiga värden är [math]lambda >= 0[/math], om vi får två värden, välj den minsta.

			Ett specialfall är när center är vid origo och radien är 1: [math]lambda^2 bb "t"_r^2 + 2 lambda (bb "t"_r * bb "p"_r) + bb "p"_r^2 - 1 = 0[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Vad är spatiala datastrukturer?
		</Question>
		<Answer>
			Det är ett sätt att dela upp objekten till ett träd, för att göra vissa operationer snabbare.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Ange olika typer av "bounding volumes".
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/BoundingVolumes.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Ange olika spatiala datastrukturer.
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/SpatialDataStructures.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur fungerar "Range Query" algoritmen?
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/RangeQueryAlgorithm.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Rendering">
		<Question>
			Hur kan vi göra för att utöka spatiala datastrukturer till annat än punkter?
		</Question>
		<Answer>
			[ul]
				[li]Dela objekt - kostsamt, ovanligt.[/li]
				[li]Överlappande noder - vanligt.[/li]
				[li]Spara samma nod flera gånger - vanligt.[/li]
			[/ul][b]Dela objekt[/b]
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/SplittingObjects.png[/img]

			[b]Överlappande noder[/b]
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/OverlappingRegions.png[/img]

			[b]Spara samma nod flera gånger[/b]
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/StoreMultipleTimes.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="VolumeRendering">
		<Question>
			Ange olika metoder för att visualisera volymer.
		</Question>
		<Answer>
			[ul]
				[li]Slicing: visualisera 2D snitt av volymen.[/li]
				[li]Direct volume rendering: Vi anser att data:n är ett medium som sänder ut ljus med specifika egenskaper. Vi visualiserar genom att simulera detta enligt fysikens lagar.[/li]
				[li]Indirect volume rendering: Omvandla/reducera volymen till någon annan representation (t.ex. ytor) och rendera dessa på vanligt sätt.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="VolumeRendering">
		<Question>
			Vad är en transfer funktion?
		</Question>
		<Answer>
			Det är en funktion som mappar värden för data:n till färger: [math]T: RR \rightarrow C[/math].
			Man kan applicera den på två sätt:
			[ul]
				[li]Pre-classification: applicera [math]T[/math] till samplad data, och interpolera sedan färger.[/li]
				[li]Post-classification: interpolera data först, och sen applicera [math]T[/math].[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="VolumeRendering">
		<Question>
			Ange någon transfer funktion.
		</Question>
		<Answer>
			Den enklaste typen av transfer funktion är "window", vilket mappar ett intervall av värden till linjär gråskala. Värden som är utanför intervallet mappas till svart eller vit. Den brukar definieras av ett center och en bredd.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="VolumeRendering">
		<Question>
			Ange olika färgskalor som används för transfer funktioner.
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/ColorMaps.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="VolumeRendering">
		<Question>
			Hur fungerar en optisk modell för volym rendering.
		</Question>
		<Answer>
			Varje punkt i volymen anses utstråla och absorbera ljus, enligt färgen och transparensen som transfer funktionen anger. Dessa bidrag integreras sedan längs vystrålen för att få den slutgiltiga bilden.

			[math]I(s) = I(s_0) e^(-tau(s_0, s)) + int_(s_0)^(s) q(hat(s)) e^(-tau(hat(s), s)) d hat(s)[/math]. Denna integral har ingen analytisk lösning allmänt, och får beräknas m.h.a. numerisk integrering.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="VolumeRendering">
		<Question>
			Hur fungerar en numerisk approximation av integralen för den optiska modellen?
		</Question>
		<Answer>
			[ul]
				[li]Diskretisera: dela upp strålen i segment som har konstant transparens och utstrålning.[/li]
				[li]Samplings intervallen är ofta lika bredda, men behöver inte vara det (detta fall kallas för importance sampling).[/li]
				[li]Vid varje sampling position, ett sample återskapas från ett voxel grid med interpolation.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="VolumeRendering">
		<Question>
			Hur fungerar ray castning?
		</Question>
		<Answer>
			[i]Steg 1: ray casting[/i]
			För varje pixel i den slutgiltiga bilden, skicka en stråle genom volymen i vys riktning.

			[i]Steg 2: sampling[/i]
			För den delen av strålen som ligger inom volymen, så samplar vi punkter med lika långt avstånd mellan varandra. Allmänt så är inte volymen justerad med vy strålen, och sampling punkterna är oftast placerade mellan voxels. Detta gör att vi ofta interpolera värdena från närliggande voxlar (oftast används trilinjär interpolation).

			[i]Steg 3: shading[/i]
			För varje sampling punkt, så beräknas en gradient av ljussättning. Detta representerar orienteringen av lokala ytor inom volymenen. Dessa ljussätts sedan enligt ytans orienteringen och placeringen av ljuskällan.

			[i]Steg 4: compositing[/i]
			Efter alla sampling punkter har ljussätts, så kombineras dessa (compositing) längs vy strålen, vilket resulterar i den slutgiltiga färgen för pixeln. Den kan antigen vara back-to-front, vilket innebär att vi börjar beräkna längst ifrån vyn och slutar närmast vyn. Alternativ, kan vi köra front-to-back.

			Fördelen med back-to-front är att gömda delar av volymen ej påverkar den slutgiltiga pixeln, men är mer beräkningskrävande än front-to-back.
		</Answer>
	</TestQuestion>
</Test>
