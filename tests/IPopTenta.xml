<?xml version="1.0" encoding="utf-8" ?>
<Test Name="Tenta">
	<TestQuestion Category="Grundläggande">
		<Question>
			Ange olika nätverkstopologier.
		</Question>
		<Answer>
			[b]Mesh[/b]
			Varje enhet är kopplad till alla andra enheter.

			[b]Star[/b]
			Enheterna är kopplade till en central enhet.

			[b]Ring[/b]
			Varje enhet är kopplad till nästa enhet.

			[b]Bus[/b]
			Varje enhet delar en gemensam länk
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grundläggande">
		<Question>
			Ange de olika överförningslägen som finns.
		</Question>
		<Answer>
			[b]Simplex[/b]
			En enhet kan bara sända, de övriga kan endast ta emot.

			[b]Half-duplex[/b]
			Två enheter kan sända och ta emot, men inte samtidigt.

			[b]Full-duplex[/b]
			Två enheter kan både sända och ta emot samtidigt.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grundläggande">
		<Question>
			Vad är en länk?
		</Question>
		<Answer>
			En länk är ett nätverk som gör det möjligt för datorer att kommunicerar med varandra.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grundläggande">
		<Question>
			Vad är en värd för något?
		</Question>
		<Answer>
			En värd (host) är en maskin med [i]en[/i] eller flera nätverksgränssnitt och kan [i]inte[/i] vidarebefordra paket mellan gränssnitten.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grundläggande">
		<Question>
			Vad är en router för något?
		</Question>
		<Answer>
			En router är en maskin med [i]två[/i] eller flera nätverksgränssnitt och kan vidarebefordra paket mellan gränssnitten.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grundläggande">
		<Question>
			Ange och förklara de olika lagren enligt OSI-modellen.
		</Question>
		<Answer>
			[b]L1: Physical[/b]
			Det fysiska lagret hanterar överförring av en ström av bitar (mellan olika noder) över ett fysiskt medium. Det fysiska lagret hanterar även: 
			[ul]
				[li]Hur bitaran representeras (t.ex. som signaler antigen elektriska eller optiska).[/li]
				[li]Överföringshastigheten - hur många bitar som överförs varje sekund.[/li]
				[li]Synkronisering av klockorna mellan sändaren och mottagaren.[/li]
				[li]Den fysiska topologin.[/li]
				[li]Överföringsläget.[/li]
			[/ul]
			[b]L2: Data Link[/b]
			Data-länk lagret transformerar det fysiska lagret till en pålitlig länk som gör att lagren ovanför uppfattar det fysiska lagret som felfri. Lagret hanterar även:
			[ul]
				[li]Uppdelning av strömmen av bitar som tagits emot till dataenheter som betecknas [i]frames[/i].[/li]
				[li]Fysisk adressering: Om olika frames ska distribueras mellan olika system på nätverket så lägger lagret till en [i]header[/i] till framen som definerar sändaren och/eller mottagaren av framen. Om ramen ska utanför nätverket, så är mottagaradressen, adressen till enheten som kopplar i samman nätverken.[/li]
				[li]Flödeskontroll: Om överföringshastigheten skiljer sig mellan mottagaren och sändaren, så begränsas hastigheten.[/li]
				[li]Felkontroll (detta uppnås vanligen genom att lägga till data s.k. trailer till slutet av framen).[/li]
				[li]Åtkomstkontroll: Om två eller flera enheter är kopplade till samma länk, så bestämmer lagret vem som har kontroll över länken på en given tidpunkt.[/li]
			[/ul]
			[b]L3: Network[/b]
			Nätverkslagret hanterar överföring ifrån källa till mottagare för ett paket, vilket kan gå över flera nätverk (länkar). Där data-länk lagret hanterar överförning av paket mellan två system inom samma nätverk, så ser nätverks lagret till att paket kommer från källan till mottagaren.

			Om två system har kopplade till samma länk, finns det oftast inget behov av nätverks lagret. Lagret hanterar även:
			[ul]
				[li]Logisk adressering: Den fysiska adressering hanterar adressering lokallt. Om ett paket går utanför nätverket, så behövs ett adresseringssystem för att avgöra olika system utanför nätverket. Detta fungerar så att nätverks lagret lägger till en header till paketet som kommer från ett lager högre upp, där headern innehåller den logisk adressen för sändaren och mottagaren.[/li]
				[li]Routing, som ser till att paket kommer till den slutgiltiga mottagaren.[/li]
			[/ul]
			[b]L4: Transport[/b]
			Transportlagret hanterar överföring av [i]meddelanden[/i] mellan processer. Ett meddelande består av en eller fler paket, som de lägre lagren [i]inte[/i] ser som något enhetligt. Lagret ser till att hela meddelandet kommer fram och i ordning. Lagret hanterar även:
			[ul]
				[li]Service-point adressering: Datorer kör ofast flera program samtidigt, detta innebär att för att rätt meddelanden ska komma till rätt process, behövs en ytterligare typ av adressering, som kallas för [i]port[/i].[/li]
				[li]Segmentering och återskapade: Ett meddelande som överförs består av olika segment, där varje segement har ett sekvensnummer. Detta nummer gör det möjligt för transport lagret att återskapa meddelandet i korrekt ordning när det kommer fram och ersätta paket som tappades på vägen.[/li]
				[li]Anslutingskontroll: Transport lagret kan antigen vara anslutingslös eller ansluten. Ett anslutingslös transport lagret behandlar varje segment som ett oberoende paket.Ett anslutet transport lagrer skapar en ansluting med transport lagret på målsidan, innan paketet börjas överföras. Efter att all data har överförts, så stängs anslutningen.[/li]
				[li]Flödeskontroll: Skillnanden mellan data-länk lagret är att flödeskontrollen sker från ändpunkt till ändpunkt istället för över en länk.[/li]
				[li]Felkontroll: Skillnanden mellan data-länk lagret är att felkontrollen sker från process till process istället för över en länk. Lagret ser till att meddelanden som kommer fram är utan fel (skadade, saknar data, data är duplicerad).[/li]
			[/ul]
			[b]L5: Session[/b]
			Sessionlagret etablerar, underhåller ocn synkroniserar interaktionen mellan system som kommunicerar med varandra. Lagret hanterar:
			[ul]
				[li]Dialogkontroll: Gör det möjligt för två processer som kommunicerar att antingen ske i half-duplex eller full-duplex läge.[/li]
			[/ul]
			[b]L6: Presentation[/b]
			Presentationslagret hanterar syntaxen och semantiken av informationen som överförs mellan de två systemet. Lagret hanterar:
			[ul]
				[li]Översättning av olika former av tecken, nummer som används av de olika systemet.[/li]
				[li]Kryptering.[/li]
				[li]Komprimering.[/li]
			[/ul]
			[b]L7: Application[/b]
			Gör det möjligt för användaren (människa eller mjukvara) att komma åt nätverket. Exempel på olika tjänster om lagret tillhandahåller är t.ex.:
			[ul]
				[li]Nätverks terminal[/li]
				[li]E-mail[/li]
				[li]Filöverföring, Filåtkomst och liknande.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grundläggande">
		<Question>
			Ange och förklara de olika lagren enligt TCP/IP.
		</Question>
		<Answer>
			Jämförelse med OSI-modellen så är Application, presentation och session lagren lagts upp till ett enda lagret, applikations lagret. TCP/IP har även flera protokoll för transport lagret. Konceptuellt så är de fyra första lagren i både OSI och TCP/IP mycket liknande varandra.

			[b]Physical[/b]
			Det fysiska lagret hanterar överförring av en ström av bitar (mellan olika noder) över ett fysiskt medium.

			[b]Data Link[/b]
			TCP/IP definerar inget specifikt protokoll för data-länk lagret utan stödjer alla standardiserade och proprietära protokoll. Enheten som används vid kommunikation kallas för en [i]frame[/i].

			[b]Network[/b]
			Det protokoll som används är IP. Enheten som används vid kommunikation kallas för [i]datagrams[/i] vilket varje överförs separat. Datagram kan skickas via olika vägar och kan komma i oordning eller duplikerade. IP håller inte koll på vägen för paketen och har ingen möjlighet för att ordna paketen i ordning när de har kommit fram.

			[b]Transport[/b]
			Huvudsakligen så används två okika protokoll i transport lagret, User Datagram Protocol (UDP) pch Transmission Control Protocol (TCP). Enheten som används vid kommunikation som används är antigen ett segment, user datagram eller ett paket, vilket beror på vilket protokoll som används

			[b]Application[/b]
			Många protokoll är definerad i detta lager som t.ex. email, HTTP, osv.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinkLayer">
		<Question>
			Vad för ansvar har länklagret?
		</Question>
		<Answer>
			Att överföra datagram mellan närliggande värdar över en länk.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinkLayer">
		<Question>
			Vad för syfte har en MAC-adress (länk adress/fysisk adress)?
		</Question>
		<Answer>
			Det används för att identifiera källa och mål inom [i]ett nätverk[/i] och är 48 bitar.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinkLayer">
		<Question>
			Vad är Carrier Sense Multiple Access (CSMA) och vad försöker det undvika?
		</Question>
		<Answer>
			Det försöker undvika att kollisioner uppstår när två noder skickar data samtidigt över en länk. CSMA fungerar så att innan man skickar, så lyssnar man över länken efter aktivitet. Kollisioner kan dock fortfarande uppstå på grund av tiden för en signal att färdas över mediet. Om en kollision upptäckts så avvaktar man och försöker senare.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinkLayer">
		<Question>
			Vad är en ethernet switch (bridge) för något?
		</Question>
		<Answer>
			Det är en enhet som styr trafiken mellan olika noder i ett nätverk. Till varje switch så sitter olika länkar kopplade till olika portar. När ett paket kommer till switchen, så vill vi helst att paketet endast skickas till målet. Detta uppnås genom att ha en tabell som matchar MAC-adress till port. Tabellen fylls genom att kolla på paket som kommer från porten, och uppdatera tabellen med hjälp av paketets källadress. Om vi får ett paket där vi inte har en post för målet i tabellen, så skickas paketet till [i]alla[/i] noder kopplade till switchen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinkLayer">
		<Question>
			Vad innebär "gömda terminal problemet" (hidden terminal problem)?
		</Question>
		<Answer>
			Vi har tre datorer: A, B och C. B och A kan höra varandra, B och C kan höra varandra men A och C kan inte höra varandra. Om det uppstår en kollision när både C och A ska skicka till B, så kan detta ej lösas för A och C vet ej att varandra existerar.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="NetworkLayer">
		<Question>
			Vad innebär det att en tjänst är anslutningsorienterad?
		</Question>
		<Answer>
			Det innebär att en anslutning etableras mellan sändare och mottagare (t.ex. telefonlinje). Detta innebär att vägen som ett paket måste ta genom nätverket bestäms en gång. Det innebär att routrarna behöver tillstånd som håller reda på detta. Det gör det också möjligt att allokera en viss mängd bandbred till en anslutning. Ett annat namn är Virtual circuit switched.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="NetworkLayer">
		<Question>
			Vad innebär det att en tjänst är anslutningslös?
		</Question>
		<Answer>
			Det innebär att ingen anslutning behövs och paketen vägen bestäms varje gång de skickas, även om de ska till samma mottagare. Detta gör att paketen kan ta olika vägar till målet. Detta gör att inget tillstånd krävs i routrarna. Detta gör det även svårt att allokera en viss mängd bandbred till en anslutning. Ett annat namn är Datagram baserat system.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="NetworkLayer">
		<Question>
			Ange olika leveransmetoder ifrån ändpunkt-till-ändpunkt.
		</Question>
		<Answer>
			[b]Direktleverans[/b]
			Mottagaren och sändaren är kopplade till [i]samma[/i] fysiska nätverk vilket innebär att mottagaradressen och lokala adressen är den samma. Den [i]sista[/i] leveransen är alltid direkt.

			[b]Indirekt leverans[/b]
			Leveransen går mellan routrar påvägen till målet, där vilka routrar som ska tas på vägen till målet bestäms av [i]forwarding-tabellen[/i].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="NetworkLayer">
		<Question>
			Ange olika sätt för forwarding.
		</Question>
		<Answer>
			[b]Källroutning (source routing)[/b]
			Källan bestämmer vilken väg som ska tas. Nackdelen är att information om nätverkets topologi behövs och kräver utrymme i paketet.

			[b]Nästa-hopp routing (next-hop routing)[/b]
			Det innebär att en router endast håller koll på nästa nod i vägen är, för ett paket. För IP så baseras det på adressen för mottagaren. Varje router sparar då en mappning ifrån värd/nätverksadress till adressen för nästa hopp.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPAdressering">
		<Question>
			Vad är syftet med nätverksmasken i IP?
		</Question>
		<Answer>
			Syftet är att ange vilken del av adressen som tillhör nätverket och värden.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPAdressering">
		<Question>
			Vad är directed broadcast address (DBA) (i IPv4)?
		</Question>
		<Answer>
			Det gör det möjligt för att skicka paket till alla värdar i ett nätverk. De flesta routrar blockeras dock detta på grund av säkerhet. Notera i IPv6 så finns inte DBA.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinkLayer">
		<Question>
			Vad är limited broadcast address (i IPv4)?
		</Question>
		<Answer>
			Det gör det möjligt att skicka ett paket till alla värdar i ett nätverk, men som routrar [i]inte[/i] skickar vidare. Adressen består endast av 1:or (255.255.255.255).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinkLayer">
		<Question>
			Vad är Global Unicast Address (i IPv6)?
		</Question>
		<Answer>
			Det gör det möjligt att ge en unik address till varje enhet i världen. Det fungerar så att de 64 första bitarna i adressen tillhör nätverket och 64 sista bitarna tillhör enheten. T.ex. så kan MAC adressen användas (48-bitar).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPAdressering">
		<Question>
			Hur anges nätverksmasken?
		</Question>
		<Answer>
			Det finns flera olika notationer, t.ex:

			[b]Prefix[/b]: /tal. Talet anger hur många bitar som är ettställda (sätt från vänster).
			[b]Dotted decimal[/b]: På samma sätt som en IP address.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPAdressering">
		<Question>
			Givet ett adress [math]A[/math] och ett nätverksmask [math]M[/math], hur beräknas då nätverksadressen (NetID)?
		</Question>
		<Answer>
			[math]NetID = A text{ &amp; } N[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPAdressering">
		<Question>
			Givet ett adress [math]A[/math] och ett nätverksmask [math]M[/math], hur beräknas då värd adressen (HostID)?
		</Question>
		<Answer>
			[math]NetID = A text{ &amp; } !N[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPAdressering">
		<Question>
			Givet ett adress [math]A[/math] och ett nätverksmask [math]M[/math], hur beräknas då directed broadcast address (DBA)?
		</Question>
		<Answer>
			[math]DBA = A text{ &amp; } N | !N[/math].
			DBA kan beräknas som nätverksadressen med HostID som bara 1:or.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="NetworkLayer">
		<Question>
			Antag att [math]n[/math] är prefix längden, hur många adresser ingår då i blocket?
		</Question>
		<Answer>
			Antalet adresser i blocket blir: [math]2^(32-n)[/math]. Vissa adresser går dock inte att tilldela till värdar (DBA och NetID), så antalet tilldelbara till värdar blir då: [math]2^(32-n)-2[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="NetworkLayer">
		<Question>
			Vad innebär adress aggregering och varför behövs det?
		</Question>
		<Answer>
			Det innebär att mindre block av adresser allokeras på ett sätt (närliggande) så att kan slås ihop till ett större block. Syfter är att minska antalet inlägg som behövs i en forwarding table.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vad är MTU?
		</Question>
		<Answer>
			Det ange länkens maximala överförings storlek. I IPv4 är det minimala värdet 576 bytes och i IPv6 1280 bytes.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Ange kort hur en IP header är uppbyggd.
		</Question>
		<Answer>
			[b]IPv4[/b]
			Headern storlek kan variera mellan 20 och 60 bytes. Om inga options används så är storleken 20 bytes. Den maximala storleken på ett paket (inklusive headern) är [math]2^16-1=65535[/math] bytes.

			[b]IPv6[/b]
			I IPv6 är headerns storlek alltid 40 bytes. Det finns dock möjligheter att ha "extension headers", som bildar en länkad lista. Om inga extension används, så är den maximala storleken på paketet samma som i IPv4, 65535 bytes.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vad innebär fragmentering av IP paket?
		</Question>
		<Answer>
			Fragmentering innebär att paket delas upp i flera delar "fragment". Syftet är att ett paket kan inte alltid skickas över en länk, om paketet är större än länkens MTU (maximala överförings storlek).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Hur fungerar fragmentering av IP paket?
		</Question>
		<Answer>
			Varje paket får ett ID, som används för att identifiera om olika fragment tillhör samma paket. Sedan får varje fragment ett offset, relativt starten av hela paketet. Syftet med offseten är för att kunna återskapa paketet. Offseten är endast 13 bitar, men storleken av paketet behöver 16 bitar. Detta innebär att offesten anger antalet 8-bytes.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Varför används offsets och inte sekvensnummer för att identifiera fragment av IP paket?
		</Question>
		<Answer>
			Detta beror på att ett fragment kan vara större än länkens MTU, vilket innebär att fragmenet kan behövas delas upp i mindre fragment. Om sekvensnummer hade används, hade detta inte varit möjligt.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vem har uppgift att fragmentera IP paket?
		</Question>
		<Answer>
			[b]IPv4[/b]
			Värdar och routers (om inte DF biten är satt).

			[b]IPv6[/b]
			Värdar. Om paketet inte kan skickas, så droppas det och sändaren meddelas.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vad händer om ett fragment i ett paket tappas bort?
		</Question>
		<Answer>
			Hela paketet kastas bort.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vem har i uppgift att återskapa paketet (av fragment), och varför?
		</Question>
		<Answer>
			Det är sändaren som har i uppgift att återskapa. Detta på grund av att olika fragment (kan) ta olika vägar till målet. Detta innebär att det är endast säkert att målet kan ha alla fragemeten, som behövs för att återskapa paketet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Hur kan man undvika att paket ingår i en oändlighets loop?
		</Question>
		<Answer>
			Genom att ha en räknare (i paketet), som räknas ner vid varje hopp. Om räknaren når 1, så droppas hela paktet. Kallas för Time To Live (TTL) i IPv4 och Hop Limit i IPv6.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vad innebär Quality of Service (QOS)?
		</Question>
		<Answer>
			Det innebär att vi ger prioritet till vissa typer av paket (video).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Hur kan vi få reda på en värds fysiska (MAC) adress, om vi vet värdens IP adress?
		</Question>
		<Answer>
			Genom att skicka en förfrågan till alla värdar på nätverket. Detta är syftet bakom Address Resolution Protocol (ARP). Detta fungerar så att vi skickar en broadcast på nätverket, att vi söker efter värden med en viss IP adress. Den värd som då har IP adressen, svarar förfrågan med sin egna MAC adress.

			I IPv6 som används inte ARP, utan ICMPv6.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Hur kan vi göra för att få Address Resolution Protocol (ARP) att bli mer effektivare?
		</Question>
		<Answer>
			[ul]
				[li]Spara hämtade adresser i en cache. Cachen måste dock tömmas periodiskt, för att värdar kan gå ner och upp.[/li]
				[li]Om vi har tagit emot ett paket ifrån en värd, spara den MAC adress (som finns med i paketet). Detta kallas för [i]ARP snooping[/i].[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vad är Proxy ARP?
		</Question>
		<Answer>
			Det innebär att en värd svarar för en annan värd (dvs att värd B är C till värd A), vilket gör det möjligt för sub-nätverk att vara gömda.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vad innebär Strict Source routing (SSRR) (i IPv4)?
		</Question>
		<Answer>
			Det innebär att ett paket [i]måste[/i] ta en specifik väg till målet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vad innebär Loose Source routing (LSRR) (i IPv4)?
		</Question>
		<Answer>
			Det innebär vägen som paketet tar till målet innehåller de specificerade adresserna, men inte vägen mellan adresserna.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IP">
		<Question>
			Vad är Internet Control Message Protocol (ICMP) för något?
		</Question>
		<Answer>
			Det är ett protokoll som används för att rapportera IP relaterade fel tillbaka till sändaren. Protokollet använder IP som transport.

			[b]Exempel på fel[/b]
			[ul]
				[li]När paketet har "dött", dvs TTL har nått noll.[/li]
				[li]Om ett paket är större en MTU (i IPv6)[/li]
				[li]Det går inte att nå målet.[/li]
			[/ul][b]Fel som inte rapporteras[/b]
			[ul]
				[li]Fel som uppstår vid leverans av felmeddelande.[/li]
				[li]Paket som ska skickas via broadcast or multicast[/li]
				[li]Fel vid fragment utöver det första.[/li]
			[/ul]
			Syftet är att undvika att loopar uppstår och en explosion av paket skickas.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Hur fungerar den distribuerade versionen av Bellman-Ford algoritm?
		</Question>
		<Answer>
			Varje router [math]r[/math] skickar en lista av distans vektorer [math]d(r, v)[/math] (kostnaden för vägen) till sina grannar (dvs andra routrar som är kopplade routen). Detta görs periodvist, för att nätverk kan gå ner och upp. När ett paket sedan ska skickas, så väljs den vägen med lägst kostnad.

			Hos varje routen [math]r[/math] så finns en post för varje [math]d[/math] i nätverket, som innehåller kostanden ([math]M(r, d)[/math]) och nästa hopp ([math]n in N(r)[/math]).

			För varje uppdatering som kommer ifrån en granne [math]n' in N(r)[/math], så uppdateras kostnaden enligt:
			[math]m=M(r,n') + M(n',d)[/math] där [math]M(n',d)[/math] är kostnaden ifrån grannen till målet [math]d[/math].

			Om [math]m \lt M(r, d)[/math]: [math]n=n', M(r,d)=m[/math] (dvs uppdatera nästa hopp för målet).

			Eller om [math]n=n'[/math]: [math]M(r,d)=m[/math] (uppdatera alltid kostnaden om vi redan har en post med den som nästa hopp).

			Kostnaden [math]M[/math] har en övre gräns, typiskt 16.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad för problem kan uppstå när distans vektorer används, och hur kan man lösa det?
		</Question>
		<Answer>
			[b]Räkna till oändlighet[/b]
			Antag att vi har två routers, [math]R1[/math] och [math]R2[/math] som är kopplade till varandra. Antag att nätverket [math]N[/math] är kopplad till [math]R1[/math] men inte [math]R2[/math].

			Om länken mellan [math]N[/math] och [math]R1[/math] går ner, så tar [math]R1[/math] bort sin länk till [math]N[/math] genom att sätta kostnaden till [math]\infty[/math](16). Två saker kan nu hända:

			1) [math]R1[/math] skickar sin väg till [math]N[/math] till [math]R2[/math], inget problem.
			2) [math]R2[/math] som fortfarande har en väg till [math]N[/math], skickar sin väg till [math]R1[/math]. För att avståndet är kortare, så uppdateras [math]R1[/math] väg.

			Det som händer är när ett paket som ska till [math]N[/math] skickas, så uppstår en loop som brtys när TTL når 0. För eller senare kommer dock kostnaden för både [math]R1[/math] och [math]R2[/math] nå 16, så att loopen bryts.

			Lösningen till problemet kallas för [i]split horizon[/i], som innebär att man inte skickar vägar tillbaka över samma gränssnitt som vägen kom ifrån. En annan variant av [i]split horizon[/i] kallas för [i]split horizon med poison reverse[/i] som innebär att man skickar tillbaka vägar över samma gränssnitt som vägen kom ifrån, [i]men[/i] med kostnanden [math]\infty[/math]. Detta ger en uppmanning att inte använda värdet, då sändaren vet att vägen kom ifrån målet.

			[b]Mutual deception[/b]
			Antag att vi har tre routers [math]R1, R2, R3[/math], där alla routers är kopplade till varandra. Om en länk går ner, så kan inte split horizon och poison reverse inte lösa problemet.Router [math]R1[/math] kan tro att den har en väg via [math]R2[/math], t.ex. [math]R2[/math] via [math]R3[/math] och [math]R3[/math] via [math]R1[/math].
			Det finns två lösningar:

			[i]Triggered update[/i]
			Skicka ut uppdatering direkt när en kostnad ändras (endast vägen som ändrades.) Detta kan leda till propagering av uppdatering. Detta innebär att man begränsar att detta inte kan ske oftare än varje 1-5 sekund. Triggered update [i]måste[/i] användas när en väg tas bort.

			[i]Hold down[/i]
			När en väg tas bort, så tillåts det inte att vägen uppdateras för en given tid. Detta ger alla routrar tid att ta bort vägen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är link-state routing?
		</Question>
		<Answer>
			Link-state routing innebär att varje router har information om nätverkets topologi. Varje router beräknar sedan den kortaste vägen till alla möjliga mål i nätverket typisk med Dijkstra's algoritm. Exempel på routing protokoll är Open Shortest Path First (OSPF) och Intermediate System to Intermediate System (IS-IS).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är path vector routing?
		</Question>
		<Answer>
			Det fungerar ungefär som distance vector routing, men istället för nätverk är det autonoma system (AS) som är noderna i vägarna.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är fördelarna med link-state routing?
		</Question>
		<Answer>
			[ul]
				[li]Mer funktionalitet p.g.a distribution av data.[/li]
				[li]Beror ej på mellanliggande routrar.[/li]
				[li]Lättare att felsöka.[/li]
				[li]Konvergerar snabbare: när nätverket förändras så beräknas nya vägar snabbt.[/li]
				[li]Kräver mindre bandbred.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är fördelarna med distance-vector routing?
		</Question>
		<Answer>
			[ul]
				[li]Mindre komplex (lättare att implementera och administrera).[/li]
				[li]Kräver mindre minne.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är ett Interior Gateway Protocol (IGP) för något?
		</Question>
		<Answer>
			Det är ett protokoll som körs inom en domän som hanterar interna routing inom domämnen. Exempel på protokoll är: RIP, OSPF, IS-IS.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är ett Exterior Gateway Protocol (EGP) för något?
		</Question>
		<Answer>
			Det är ett protokoll som utbyter vägar mellan olika domäner som hanterar externa vägar. Exempel på protokoll BGP.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är Routing Information Protocol (RIP) för något?
		</Question>
		<Answer>
			Det är ett protokoll som hanterar vägar inom en domän (IGP) och bygger på distans vektorer. Noder inom en domän som använder RIP är routers och nätverk (länkar). Målet i routing tabellen är alltid ett nätverk. Kostnaden som används är antalet hopp som krävs för att komma till målet. Om kostnaden är 1 betyder det att routrarna är kopplade på samma nätverk och 16 betyder oändliget. Detta innebär att endast domäner av diameter mindre än 16 stöds.

			Inom RIP, så finns de två typer av meddelanden: förfrågningar och svar. En förfrågan är ett meddelandet som skickas av en router som nyligen har startas eller av en router är poster i tabellen har blivit för gamla (time-out). En förfrågan kan vara om specifika poster eller alla poster.

			Det finns två typer av svar: solicited eller unsolicited. Ett svar som är [i]solicited[/i] skickas endast som ett svar till en förfrågan, vilket innehåller information om målet som förfrågades. Ett svar som är [i]unsolicited[/i] skickas ut periodvist varje 30 sekund, eller när en post ändras i tabellen.

			Det finns tre typer av timers som används i RIP. Den första timern, den periodiska hanterar utskickning av uppdateringar (25-35s). Den andra hanterar när en post i tabellen anses vara för "gammal", vilket typiskt är satt till 180s. Den sista timern (skräpsamling) hanterar när en väg som har blivit ogitlig tas bort ifrån tabellen (som typisk är 120 s). Syftet med denna timer är att göra grannar uppmärksamma att en väg har blivit ogiltig innan den tas bort.

			Protokollet använder sig av UDP för att skicka meddelanden. I version 1 så används broadcast, i version 2 så används en speciell "router broadcast" adress, 224.0.0.9 för IPv4 och FF02::9 för IPv6.

			[b]Fördelar[/b]
			[ul]
				[li]Lätt att implementera.[/li]
				[li]Lätt att konfigurera.[/li]
				[li]Liten overhead för små nätverk.[/li]
				[li]Finns tillgängligt i många system.[/li]
				[li]Implementationer har testas noggrant.[/li]
			[/ul][b]Nackdelar[/b]
			[ul]
				[li]Konvergerar segt, vilket innebär att förändringar propageras sakta.[/li]
				[li]Instabilt: När en router eller länk går ner, tar det flera minuter för RIP att stabiliseras.[/li]
				[li]Antalet hopp är inte det bästa indikator för bästa vägen.[/li]
				[li]Begränsad nätverks diameter ([math]\le 15[/math]).[/li]
				[li]Använder mycket bandbredd.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är Open Shortest Path First (OSPF) för något?
		</Question>
		<Answer>
			Det är ett protokoll som hanterar vägar inom en domän (IGP) och bygger på link-state. För att hantera vägar effektivt, så delas domänen upp i områden. Ett område är en samling nätverk (där alla nätverk måste vara anslutna till varandra), värdar och routers som alla finns inom samma domän. Kostnaden som används är ej definerad av protokollet, men är ofta relaterad till länkens hastighet.

			Vid gränsen av ett området, finns det en speciell router som kallas för "area border router" (ABR) som sammanfattar informationen om området och skickar till andra områden. Det finns ett speciellt område, kallat [b]backbone[/b] som alla andra områden [i]måste[/i] vara kopplad till. En router som ligger i backbone kallas för [i]backbone router[/i].

			Inom varje området finns det också en så kallad [i]designated router[/i] (DR) och en backup (BDR). Syftet med DR är att istället för att skicka alla uppdateringar till närliggande routers inom nätverket, så skickas uppdateringar till DR, vilket i sin tur behandlar dessa och skickar till andra routers inom området.

			Det finns fyra typer av länkar:
			[ul]
				[li]Point-to-point: Kopplar samman två routers utan några andra routers eller värdar mellan.[/li]
				[li]Transient: Är ett nätverk med flera routers kopplade till nätverket, där data kan ankomma och lämna nätverket via vilken router som hlest.[/li]
				[li]Stub: Är ett nätverk som endast är kopplad till en router.[/li]
				[li]Virtual: När en länk mellan två routers går sönder, så kan en administratör skapa en virtuell länk mellan dem genom en längre väg som går sannolikt går genom flera routers.[/li]
			[/ul]Huvudkomponenterna inom protokollet är:
			[ol]
				[li]Hello protokoll: Används för att upptäcka närliggande routers och välja vilken router som är DR.[/li]
				[li]Exchange protokoll: Utbyte av link-state mellan närliggande routers.[/li]
				[li]Reliable flooding: När en länk uppdateras eller bli för gammal så uppdateras närliggande routers, som i sin tur uppdaterar närliggande routers, osv.[/li]
				[li]Beräkning av kortaste väg (till alla mål) med hjälp av Diskstras algoritm.[/li]
			[/ol]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är ett Autonomous System (AS)?
		</Question>
		<Answer>
			Det är en samling av routers som har samma routing policy och administreras av samma grupp. Det kan vara ett nätverk eller en grupp av nätverk. Exempel är universitet, företag, organisationer, operatörer.

			Varje AS har ett nummer (16-bitar) och alla interna policyer, protokoll, osv är gömda inom systemet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Ange olika typer av Autonomous Systems
		</Question>
		<Answer>
			[b]Stub AS[/b]
			Är ett system som endast är kopplad till ett annat system.

			[b]Multihomed AS[/b]
			Är ett system som har fler än en koppling till andra system, men fungerar endast som ett mål eller källa för trafik. Dvs, den tillåter inte trafik ifrån en annan AS att gå genom systemet vidare till ett annat system.

			[b]Transit AS[/b]
			Är ett multihomed AS som tillåter att trafik (ifrån andra AS) passerar systemet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Routing">
		<Question>
			Vad är Border Gateway Protocol (BGP) för något?
		</Question>
		<Answer>
			Det är ett protokoll som hanterar externa vägar (EGP) och bygger på path-vector routing. Det finns två varianter av BGP, E-BGP: som hanterar utbyte av externa vägar mellan olika AS (border routers). I-BGP: Synkroniserar externa vägar inom ett AS. Protokollet använder sig av TCP. BGP interagerar också med interna routing protokoll (RIP, OSPF) och distribuerar interna och externa routing information mellan protokollen.

			Varje väg till ett mål har olika attributer som används av routers för att göra ett bättre beslut när policyer tillämpas. Exempel på attributer är ORIGIN som anger källan av routing informationen (RIP, OSPF), AS_PATH som anger de AS som målet kan nå och NEXT-HOP som anger nästa router som paktet ska skickas till.

			BGP använder sig av fyra olika meddelanden:
			[ul]
				[li][b]Open[/b]: Används för att skapa en relation med en granne. Om grannen accepterar relationen, så skickas ett [b]keepalive[/b] meddelande.[/li]
				[li][b]Update[/b]: Används för att ta bort och skapa nya mål.[/li]
				[li][b]Keepalive[/b]: Används för att indikera för grannar att de lever, vilket görs periodiskt.[/li]
				[li][b]Notification[/b]: Används när fel har upptäcks eller när en router vill stänga ner anslutningen.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Ange de två vanligaste protokollen i transport lagret och vad för idér de bygger på.
		</Question>
		<Answer>
			[b]User Datagram Protocol (UDP)[/b]
			[ul]
				[li]Connectionless[/li]
				[li]Opålitlig[/li]
				[li]Meddelande orienterat[/li]
				[li]Simplex/Semi-duplex[/li]
			[/ul][b]Transport Control Protocol (TCP)[/b]
			[ul]
				[li]Connection-oriented[/li]
				[li]Pålitlig[/li]
				[li]Ström orienterat[/li]
				[li]Full-duplex[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad är en portnummer (i transport lagret) för något?
		</Question>
		<Answer>
			Det används för att identifiera processen som paketet skickas från/skickas till. Notera att ett portnummer är en 16-bitars heltal.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad är en socket för något?
		</Question>
		<Answer>
			Det är en IP-adress och ett portnummer. Varje meddelande som skickas i transport lagret måste ha en källsocket och målsocket.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Ange tre olika klasser av portnummer som finns
		</Question>
		<Answer>
			[b]Well-known portar (0-1023)[/b]
			Tilldelas och kontrolleras av IANA. Används normalt för primär tjänster (HTTP).

			[b]Registerade portar (1024-49151)[/b]
			Dessa registeras hos IANA, men det är inget som förhindrar en att använda dessa portar. Används normalt av applikations tjänster.

			[b]Dynamisk portar (ephemeral) (49152-65535)[/b]
			Dessa kan används av vilka processer som helst. Dessa används normalt av klient processer.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Ange hur ett UDP-paket är uppbyggd.
		</Question>
		<Answer>
			[b]Header[/b]
			Headern är alltid 8 bytes stor och består av källsocket, målsocket, längden av UDP paketet (16-bitar) och en checksumma (16-bitar). För IPv4 så är checksumman valfri att beräkna men i IPv6 måste den beräknas.

			[b]Data[/b]
			IPv4: För att 20 bytes används för IP header och 8 bytes för UDP header blir den maximala storleken för datan: 65507.
			IPv6: 40 bytes för IP header och 8 bytes UDP header ger: 65527.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad innebär segmentring?
		</Question>
		<Answer>
			I TCP så levereras data som en ström av bytes. Men i verkligheten så skickas data i olika block "segment". För att länkens ska utnyttjas maximalt så borde så många data skickas samtidigt i ett segment, men man får inte heller vänta för länge innan man skickar för då uppstå latens problem.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad är MSS?
		</Question>
		<Answer>
			Det står för Maximum Segment Size och anger den största block av data som TCP kommer skicka i ett paket. Om inte värde har meddelas (som endast kan göras när anslutingen etableras) så används ett default värde: 536 bytes för IPv4 och 1220 för IPv6.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad för tekniker används för att göra TCP pålitligt?
		</Question>
		<Answer>
			Varje byte som skickas får ett sekvensnummer. När data sedan skickas så väntar sen som skickar på ett ACK (acknowledgement). Om inte ett ACK har mottagits inom en viss tid (RTO, Retranission Timeout), så skickas segmentet om. Om data mottagits i oordning eller duplikerats så kastas den datan. RTO beräknas dynamiskt baserat på RTT (Round Trip Time), tiden för att skicka ett paket och få ett ACK för det.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad är Karns algoritm för något och vad för problem löser den?
		</Question>
		<Answer>
			[b]Scenario[/b]
			Ett segment skickas igen. När ACKet sedan tas emot, så vet inte sändaren om ACK var för original segmenet eller det återskickade segmentet. Detta är ett problem för att tiden mellan skicka och ta emot ACK (RTT) används för att beräkna RTO. En lösning kallas för Karns algoritm (en annan lösning är att använda sig av tidsstämplar).

			[b]Karns algoritm[/b]
			Den fungerar så att man [i]inte[/i] tar med RTT för ett segment som har skickas flera gånger, när man t.ex. beräknar RTO.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad är Nagles algoritm för något?
		</Question>
		<Answer>
			It works by combining a number of (small) outgoing packets into a larger packet. The algorithm buffers its output as long as there are unconfirmed data, and sends it when an acknowledgment is received or the packet is greater than the maximum segment size. This is often used in interactive sessions (e.g. SSH, Telnet) which generates many short messages.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad innebär delayed acknowledgement?
		</Question>
		<Answer>
			It works by delaying when an acknowledgement is sent. The acknowledgement that is later sent combines several acknowledgements into one. It is used to reduce the network traffic, since each acknowledgement has overhead example in the case of many small packets..
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad innebär Piggybacked acknowledgement?
		</Question>
		<Answer>
			Det innebär att vi bäddar in data med ACKs, för att öka effektiveten.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Hur fungerar sliding window flow control?
		</Question>
		<Answer>
			When the receiver sends an acknowledgment, he also sends a window size (rwnd). This is the maximum size of data the receiver can handle and hence can be sent by the transmitter. When the receiver has handled the data and can receive more, an updated value for rwnd is sent so the transmitter know he can start send more data. The mechanism is used so that the receiver doesn’t get overwhelmed with data he cannot handle.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad innebär slow start och congestion avoidance?
		</Question>
		<Answer>
			Congestion window (cwnd) is maintained by the sender which determines how much data that can be on the wire, traveling to the receiver. At the beginning of the connection, the congestion window is set to the maximum segment size (MSS). After each acknowledgement is received, the size of the window is increased by the MSS (exponential growth). The slow start is stopped when the size of the window reaches a threshold, ssthresh.

			Instead of increasing the cwnd exponential, the window increases linearly with the formula [math]text{cwnd}=text{cwnd}+text{MSS}/text{cwnd}[/math], until the receiver advertised that the window size is reached. When congestion happens (example when the ACK timeout occurs), we restart the slow start phase with and [math]text{sshtresh}=text{cwnd}/2[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad innebär fast retransmit och fast recovery?
		</Question>
		<Answer>
			When a segment is lost or delivered out of order, the slow start phase starts. This leads to poor utilization of the network. When three or more duplicate acknowledgement is received in a row: retransmit immediately (fast retransmit) and do congestion avoidance instead of slow start (fast recovery).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Vad är Bandwidth-Delay Product?
		</Question>
		<Answer>
			Det anger kapacitetet för länken. Den beräknas som: [math]text{BDP}=text{bandwidth}*text{RTT}[/math]. För att länken ska kunna utnyttjas maximalt, så ska storleken av receiver window vara BDP.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TransportLayer">
		<Question>
			Hur etableras en TCP anslutning?
		</Question>
		<Answer>
			Den etableras med en såkallad "three-way handshake".
			[ul]
				[li]Sen som ska etablera (klienten) anslutningen skickar ett TCP paket med flaggan SYN och ett sekvensnummer [math]x[/math].[/li]
				[li]Den som anslutingen ska etableras till (servern) skickar då ett svar som har båda flaggorna SYN och ACK satta (där [math]x[/math] ACKas) och ett eget sekvensnummer [math]y[/math].[/li]
				[li]När klienten får SYN-ACK meddelandet så skickar den ett ACK paket med sekvensnummer [math]x+1[/math] som ACKar [math]y+1[/math].[/li]
			[/ul]Efter detta är klart, så är anslutningen etablerad, och data kan då skickas i båda hållen. [math]x[/math] och [math]y[/math] bör väljas så att olika TCP anslutingar mellan ändpunkterna har olika värden. Detta uppnås genom att slumpa [math]x[/math] och [math]y[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DHCP">
		<Question>
			Ange vad för socket adresser som används av klienter och server i DHCP.
		</Question>
		<Answer>
			[b]Request (klient [math]->[/math] server)[/b]
			källa: 0.0.0.0:68 (klienten vet ej sin egen IP!).
			mål: 255.255.255.255:67 (vi vill nå alla DHCP servrar!).

			[b]Reply (server [math]->[/math] klient)[/b]
			källa: &lt;server IP&gt;:67
			mål: 255.255.255.255:68.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DHCP">
		<Question>
			Skissa på hur ett scenario ser ut, när en klient kommer online och vill få reda på sin IP m.h.a DHCP.
		</Question>
		<Answer>
			Antag att det finns en DHCP server med IP adressen 223.1.2.5 och en klient som nyligen kopplat upp sig till nätverket.

			[b]DHCP discover (klient [math]->[/math] server)[/b]
			Klienten skickar ett DHCP discover meddelande över broadcast.
			källa: 0.0.0.0:68.
			mål: 255.255.255.255:67.
			klient adress: 0.0.0.0.
			transaktions ID: 654.

			[b]DHCP offer (server [math]->[/math] klient)[/b]
			En DHCP server skickar ett erbjudade till klienten.
			källa: 223.1.2.5:67.
			mål: 255.255.255.255:68.
			erbjuden adress: 223.1.2.4.
			transaktions ID: 654.
			Livstid (hur länge klienten får använda IP innan den behövs förnyas): 3600 sekunder.

			[b]DHCP request (klient [math]->[/math] server)[/b]
			Klienten accepterar erbjudandet.
			källa: 0.0.0.0:68.
			mål: 255.255.255.255:67.
			klient adress: 0.0.0.0.
			transaktions ID: 654.
			Livstid: 3600 sekunder.

			[b]DHCP ACK (server [math]->[/math] klient)[/b]
			Server har nu allokerat IP adressen till klienten och när klienten tar emot meddelandet kan IP adressen börja användas av klienten.
			källa: 223.1.2.5:67.
			mål: 255.255.255.255:68.
			erbjuden adress: 223.1.2.4.
			transaktions ID: 654.
			Livstid: 3600 sekunder.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DHCP">
		<Question>
			Vad innebär DHCP relay?
		</Question>
		<Answer>
			Det innebär att klienten och DHCP server är på olika subnätverk. För att limited broadcast används så forwardar inte routrar meddelanden. Det finns då en speciell värd på subnätverket, DHCP relay agent som skickar vidare DHCP förfrågningar till den centrala servern.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DNS">
		<Question>
			Vad innebär det att en DNS server är auktoritet (authoritative) för en domän?
		</Question>
		<Answer>
			Det innebär att servern har konfigureras med en mapping (dvs förstahands) för domänen. T.ex. en cache kan ha samma information, men den har [i]inte[/i] konfigureras med informationen. En authoritative DNS har ett DNS inlägg av typen NS för domänen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DNS">
		<Question>
			Hur fungerar rekursiv uppslagning av en DNS post?
		</Question>
		<Answer>
			Det innebär om den som man ställer frågan till inte har ett svar, så skickas förfrågan vidare till en annan server.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DNS">
		<Question>
			Hur fungerar en iterativ uppslagning av en DNS post?
		</Question>
		<Answer>
			Först skickar man förfrågan till en server. Om den inte har ett svar på frågan, får man tillbaka möjliga servers som kan ha svaret. Då ställer man istället samma fråga till dessa servers, om dessa inte har något svar, får man tillbaka, osv.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DNS">
		<Question>
			Vad innebär delegering när det kommer till DNS?
		</Question>
		<Answer>
			Det innebär att vi delegerar ansvar till någon annan för de delar av trädet som är på en lägre nivå i trädet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DNS">
		<Question>
			Vad är en zone när det kommer till DNS?
		</Question>
		<Answer>
			En zon är en domän, minus allt som har delegeras till zonen. Det innebär att föräldrar zonen refererar till namn serveren av den zonen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Ange de två olika lägen som IPSec använder sig av.
		</Question>
		<Answer>
			[b]Transport[/b]
			Används för att tillhandahålla tjänster mellan värd-till-värd eller värd-till-gateway. Detta används vanligaste inom samma nätverk, men kan också vara från ändpunkt-till-ändpunkt över nätverk.

			[b]Tunnel[/b]
			Används för att tillhandahålla tjänster tjänster mellan gateway-till-gateway eller värd-till-gateway. Används ofta där båda gatewayarna ägs av samma organisation, men är kopplade över ett osäkert nätverk.

			Fördelen med tunnel mode att det endast kräver att IPSec stöds av gatewayarna, och existerade applikationer/API behövs ej förändras.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Hur ser ett paket ut som använder sig av IPSec ut i tranport läge?
		</Question>
		<Answer>
			Det är endast datan i IP paketet som enkapsulera av IPsec, vilket innebär att orginal IP headern är oförändrad. Det läggs även till en IPSec header. Dvs: |IP header|IPSec header|TCP/UDP header + data|.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Hur ser ett paket ut som använder sig av IPSec i tunnel läge?
		</Question>
		<Answer>
			Hela IP paketet enkapsulera av IPSec. Detta innebär att en ny IP header läggs till för gatewayarna. Det läggs även till en IPSec header. Dvs: |IP header (gateway)|IPSec header|IP header (riktiga mål)|TCP/UDP header + data|.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Vad innebär en Security Association (SA)?
		</Question>
		<Answer>
			En SA anger hur paket ska behandlas (vilken krypteringsalgoritm som ska användas, IPsec läge, nycklar, om det är AH/ESP, sevkensnummer, livstider). En SA är ett envägs förhållande mellan en sändare och skickare. En SA identiferas unikt av (SPI, måladress, flagga) där:
			[ul]
				[li]SPI: Security Parameter Index, som skickas med paketet. Väljs av målet om trafiken inte är multicast.[/li]
				[li]Flagga: ESP eller AH[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Vad är AH för något och vad för typ av säkerhet ger den?
		</Question>
		<Answer>
			AH står för Authentication Header och tillför integritet (paketet har ej ändrats) och autentisering (paketet kommer verkligen från den som skickade).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Vad är ESP för något och vad för typ av säkerhet ger den?
		</Question>
		<Answer>
			ESP står för Encapsulating Security Payload och tillför integritet (paketet har ej ändrats) och autentisering (paketet kommer verkligen från den som skickade) och sekretess (confidentiality, endast den som skickar och tar emot kan läsa klar text versionen av data).

			[b]Transport läge[/b]
			|Original IP header|ESP header|Data|ESP trailer|ESP auth|. ESP ger sekretess för |Data|ESP trailer| och autentisering för |ESP header|Data|ESP trailer|.

			[b]Tunnel läge[/b]
			|Ny IP header|ESP header|Original IP header|Data|ESP trailer|ESP auth|. ESP ger sekretess för |Original IP header|Data|ESP trailer| och autentisering för |Original IP header|ESP header|Data|ESP trailer|.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Vad för typ av attacker skyddar cookies emot?
		</Question>
		<Answer>
			Denial-of-services (DOS). Cookies skyddar genom om anfallaren förfalskar sin källaddress, får den inget svar. Det som tar tid är att utföra Diffie-Hellmann beräkningarna, som cookies undviker. En cookie bör inte ha tillstånd och beräknas vanligen som: [math]text{cookie}=text{hash}(text{IP adress}, text{secret})[/math] där [math]text{secret}[/math] är känd av båda parterna.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Vad för typ av attacker skyddar Nonces emot?
		</Question>
		<Answer>
			Replay attacker. En replay attack innebär att anfallaren lyssnar på kommunikationen mellan A och B. Sedan använder sig anfallaren sig av A autentisering för att få tillgång till B. En nonce är ett sekvensnummer (t.ex. slumpad) som endast används [i]en[/i] gång.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Hur görs ömsesidig autentisering (mutual authentication) i IKE?
		</Question>
		<Answer>
			Det görs med Deffie-Hellmans algoritm.

			1. Välj ett primtal [math]q[/math] och [math]alpha[/math] som är en primitiv rot av [math]q[/math] (dvs [math]alpha[/math] genererar den multiplikativa gruppen [math]Z_q[/math]).
			2. Alice genererar en nyckel på följande sätt: Välj den privata nyckeln [math]X_A \lt q[/math] och den publika nyckeln [math]Y_A = alpha^(X_A) mod q[/math].
			3. Bob privat: [math]X_B \lt q[/math], publik: [math]Y_B = alpha^(X_B) mod q[/math].
			4. Byt publika nycklar ([math]Y[/math]).
			5. Alice beräknar en hemlig kod: [math]K = Y_B^(X_A) mod q[/math].
			6. Bob (vilket blir samma): [math]K=Y_A^(X_B) mod q[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IPSec">
		<Question>
			Ange de två faserna i IKE.
		</Question>
		<Answer>
			[b]Fas 1 (main mode)[/b]
			Gör ömsesidig autentisering och etablerar IKE sessions nycklar. Detta sätter upp "huvud" SA.
			Ex:
			[img]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/IKE.png[/img].

			[b]Fas 2[/b]
			Sätter upp en eller flera IPSec SA mellan noderna med hjälp av nycklarna som togs fram i fas 1.

			Syftet med att ha två faser är om flera SA behövs eller om SA parameterar behövs ändras, så kan detta göras utan en ömsesidig autentisering.
		</Answer>
	</TestQuestion>
</Test>
