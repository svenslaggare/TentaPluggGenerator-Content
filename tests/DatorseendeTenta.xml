<?xml version="1.0" encoding="utf-8" ?>
<Test Name="Tenta">
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad är en "perspective projection" för något?
		</Question>
		<Answer>
			Det är en mappning ifrån 3D värld till ett 2D plan.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/PerspectiveProjection.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad är en "pinhole camera" för något?
		</Question>
		<Answer>
			Det är den enklaste typen av avbildningsenhet vilket fångar in geometrin av en perspective projection. Det fungerar så att ljuset kommer in i kameran genom en öppning som är oändligt liten. Skärningen mellan ljusstrålen och bildplanet bildar bilden av objektet.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/PinholeCamera.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad är syftet med linser?
		</Question>
		<Answer>
			Syftet är att fånga in ljus från en större öppning (aperture). Problemet är att endast ljusstrålar från punkter på fokalplanet skär samma punkt i bildplanet. Resultatet blir att det blir suddigt framför eller bakom bilden. Fokaldjupet anger intervallet av avstånd med acceptabel suddighet.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/Lenses.png[/img]		
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Ange olika kamera modeller.
		</Question>
		<Answer>
			[b]Perspective projection (general kamera modell)[/b]
			Alla ljusstrålar konvergerar emot en gemensampunkt - fokalpunkten.

			[b]Orthographic projection (approximation för objekt långt borta)[/b]
			Alla ljusstrålar är vinkelrätta emot bildplanet.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/CameraModels.png[/img]	
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Ange ekvationerna för olika typer av projektioner.
		</Question>
		<Answer>
			[b]Perspective projection[/b]
			[math]x/f = X / Z, y / f = Y / Z[/math]

			[b]Orthographic projection[/b]
			[math]x = X, y = Y[/math]

			[b]Scaled orthography - [math]Z_0[/math]: representativa djupet[/b]
			[math]x / f = X / Z_0, y / f = Y / Z_0[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad är en perspektiv transformation för något?
		</Question>
		<Answer>
			Den består av tre komponenter:
			[ul]
				[li]Rotation: från världen till kamerans koordinatsystem[/li]
				[li]Translation: från världen till kamerans koordinatsystem[/li]
				[li]Perspective projection: från kameran till bildkoordinater[/li]
			[/ul]Dessa egenskaper bevaras:
			[ul]
				[li]Linjer projiceras till linjer[/li]
				[li]Kolinjära egenskaper förbli kolinjära[/li]
				[li]Tangenta egenskaper förbli Tangenta[/li]
				[li]Skärningar bevaras[/li]
			[/ul]Varje mängd av parallella linjer möts vid en viss punkt - vanishing point. Mängder av parallella linjer på samma plan leder till kolinjära vanishing points, denna linje kallas för horisonten för planet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad är homogena koordinater?
		</Question>
		<Answer>
			Modellerar punkter [math](X, Y, Z)[/math] i [math]RR^3[/math] av [math](kX, kY, kZ, k)[/math] där [math]k != 0[/math] är godtycklig. Vi anser även att [math](k_1 X, k_1 Y, k_1 Z, k_1)[/math] är ekvivalent med [math](k_2 X, k_2 Y, k_2 Z, k_2)[/math].

			Homogena koordinater innebär att vi ser alla punkter på samma stråle [math](cx, cy, c)[/math] som ekvivalenta, om vi endast vet avbildningen och inte djupet. Det blir också möjligt att modellera punkter vid oändligheten som [math](X, Y, Z, 0)[/math], vilket anger skärningen för parallella linjer.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Hur kan projektionsekvationerna skrivas m.h.a. homogena koordinater?
		</Question>
		<Answer>
			[math]((cx), (cy), (c)) = ((f, 0, 0, 0), (0, f, 0, 0), (0, 0, 1, 0)) ((kX), (kY), (kZ), (k)) = ((fkX), (fkY), (kZ))[/math]

			Bildkoordinater kan fås genom att normalisera så att den tredje komponenten blir 1 (dela med [math]c=kZ[/math]):
			[math]x = (xc) / c = (fkX) / (kZ) = f X / Z, y = (yc) / c = (fkY) / (kZ) = f Y / Z[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Ange hur transformationer ser ut i homogena koordinater.
		</Question>
		<Answer>
			[b]Translation[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((1, 0, 0, Delta X), (0, 1, 0, Delta Y), (0, 0, 1, Delta Z), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]

			[b]Skalning[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((S_X, 0, 0, 0), (0, S_Y, 0, 0), (0, 0, S_Z, 0), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]

			[b]Rotation runt Z-axeln[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((cos \theta, -sin \theta, 0, 0), (sin \theta, cos \theta, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]

			[b]Spegling i XY planet[/b]
			[math]((X), (Y), (Z), (1)) \rightarrow ((1, 0, 0, 0), (0, 1, 0, 0), (0, 0, -1, 0), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad innebär extrinsic kameraparameterar?
		</Question>
		<Answer>
			Hur kameran är roterad och förflyttad i verkliga världen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad innebär intrinsic kameraparameterar?
		</Question>
		<Answer>
			[ul]
	    		[li]Principal point (mitten av optiska axeln i bilden): [math](u_0, v_0)[/math].[/li]
	    		[li]Brännvidd: [math](f_x, f_y)[/math][/li]
	    		[li]Hur x och y-axlarna är förvrängade mellan varandra (skew): [math]gamma[/math][/li]
	    		[li]Linsförvrängning[/li]
	    	[/ul]Detta sammanfattas av: [math]P = (((f_x), gamma, u_0, 0), (0, (f_y), v_0, 0), (0, 0, 1, 0))[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad är en affine kamera?
		</Question>
		<Answer>
			Det är en linjär approxmation av en perspektiv projektion.
			[math]((x), (y), (1)) = ((m_11, m_12, m_13, m_14), (m_21, m_22, m_23, m_24), (0, 0, 0, 1)) ((X), (Y), (Z), (1))[/math].

			De grundläggande egenskaperna är att transformationen är linjär och parallella linjer i 3D avbildas till parallella linjer i 2D. Vinklar bevaras dock ej.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ProjektionerOchTransformationer">
		<Question>
			Vad innebär image warping?
		</Question>
		<Answer>
			Det innebär att man skapar en ny bild [math]g(u, v)[/math] av en bild [math]f(x, y)[/math] genom att transformera [math]u = u(x, y), v = v(x, y)[/math]. Detta görs genom att man samplar ifrån [math]f(x, y)[/math] antingen genom:
			[ul]
				[li]Nearest neighbour look-up (ger brusigt resultat)[/li]
				[li]Bilinear interpolation (ger suddigt resultat)[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grafteori">
		<Question>
			Ange olika typer av "neighbourhoods".
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/Neighbourhood.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grafteori">
		<Question>
			Vad är en stig (path)?
		</Question>
		<Answer>
			En stig ifrån [math]p[/math] till [math]q[/math] är en mängd av punkter [math]p_0, ..., p_n[/math] så att varje punkt [math]p_i[/math] är en granne till [math]p_(i - 1)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grafteori">
		<Question>
			Vad är en sammanhängande komponent (connected component)?
		</Question>
		<Answer>
			För varje [math]p[/math] så mängden av alla punkter [math]q[/math] där det finns en stig mellan [math]p[/math] och [math]q[/math] dess sammanhängande komponent.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grafteori">
		<Question>
			Vad innebär en outer boundary?
		</Question>
		<Answer>
			Bakgrundspunkter som har en granne som är inom objektet.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/OuterBoundary.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grafteori">
		<Question>
			Ange olika typer av mäta avstånd.
		</Question>
		<Answer>
			[ul]
				[li]Euclidean distance: [math]d(p, q) = sqrt((p.x - q.x)^2 + (p.y - q.y)^2)[/math][/li]
				[li]City block distance: [math]d(p, q) = |p.x - q.x| + |p.y - q.y|[/math][/li]
				[li]Chessboard distance: [math]d(p, q) = max(|p.x - q.x|, |p.y - q.y|)[/math][/li]
			[/ul]Alla dessa metoder uppfyller:
			[ul]
				[li][math]d(p, q) >= 0[/math][/li]
				[li][math]d(p, q) = d(q, p)[/math][/li]
				[li][math]d(p, r) le d(p, q) + d(q, r)[/math][/li]
			[/ul][img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/Distances.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Grafteori">
		<Question>
			Vad är en distanstransform?
		</Question>
		<Answer>
			Det är en typ av avbildning som visar avståndet till närmaste gräns för varje punkt.
		</Answer>
	</TestQuestion>
	<!-- Något om Distance transform for matching shapes? -->

	<TestQuestion Category="LinjäraFilter">
		<Question>
			Vad för egenskaper har en linjär operation?
		</Question>
		<Answer>
			[b]Definition[/b]
			[ul]
				[li]Additivet: [math]L(f(x, y) + g(x, y)) = L(f(x, y)) + L(g(x, y))[/math][/li]
				[li]Homogenitet: [math]L(alpha f(x, y)) = alpha L(f(x, y))[/math][/li]
			[/ul]där [math]f(x, y), g(x, y)[/math] är bilder, [math]alpha in RR[/math] och [math]L[/math] en operator.

			[math]L[/math] säges vara shift-invariant om och endast om en shift (translation) av indata resulterar i samma shift i utdatan. Alternativt: [math]L[/math] är kommutativ med en shift operator [math]S[/math].
			<!-- [b]Egenskaper speciellt för filter[/b]
			[ul]
				[li]Shift-invariance: om systemet ges två impulser med en tidsfördröjning, så är responsen den samma utom för tidsdifferensen.[/li]
				[li]Signaler kan representeras som summor av impluser av olika styrkor (bildintensitet), förskjutna i tiden (bildrymden)[/li]
				[li]Impulse-response function: Om vi vet hur systemet reagerar till en implus, så vet vi hur den reagerar till en kombination av impluser.[/li]
			[/ul] -->
			<!-- [b]Shift-invariant[] -->
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinjäraFilter">
		<Question>
			Hur representeras och appliceras ett linjärt filter?
		</Question>
		<Answer>
			Den representeras av en filter kernel, och appliceras m.h.a faltning (convolution) på bilden.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinjäraFilter">
		<Question>
			Hur är faltning definierad?
		</Question>
		<Answer>
			[b]Kontinuerlig[/b]
			[math]f(x) ** g(x) = int_(alpha in R^n) f(alpha) g(x - alpha) d alpha[/math]. Faltning är också kommutativ: [math]f(x) ** g(x) = g(x) ** f(x) = int_(alpha in R^n) g(alpha) f(x - alpha) d alpha[/math].

			[b]Diskret[/b]
			Faltningen av en bild [math]f(x, y)[/math] med en kernel [math]h(x, y)[/math] definieras som:
			[math]g(x, y) = h(x, y) ** f(x, y) = sum_(m=-M)^M sum_(n=-N)^N h(m, n) f(x - m, y - n)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="LinjäraFilter">
		<Question>
			Vad för relation finns det med en shift-invariant operator och faltning?
		</Question>
		<Answer>
			Varje shift-invariant operator kan skrivas som en faltning [math]L(f) = g ** f[/math].

			[b]Kontinuerlig[/b]
			[math]L(f(x)) = int_(alpha in R^n) g(alpha) f(x - alpha) d alpha[/math]

			[b]Diskret[/b]
			[math]L(f(x)) = sum_(alpha in R^n) g(alpha) f(x - alpha)[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad är en Fourier transformation för något?
		</Question>
		<Answer>
			Det är en formel för att beräkna frekvens, amplitud och fasen för varje sinusvåg som behövs för att representera en given signal. Fourier transformationen konverterar en signal (bild) mellan spatial och frekvensdomänen.
	<!-- 		I Fourier rymden, så representerar varje punkt en specfik frekvens som förvarades i den spatiala domänen. -->
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad för för- och nackdelar finns det för en spatial representation och en frekvens representation?
		</Question>
		<Answer>
			Notera: båda representationerna innehåller lika mycket information.
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/SpatialVsFourie.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad anger den spatiala frekvensen?
		</Question>
		<Answer>
			Den anger med vilken hastighet som pixel intensiteten förändras.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad för relation finns det mellan basbyte och Fourier transformationen?
		</Question>
		<Answer>
			Fourier transformationen kan ses som ett basbyte, där baserna i den spatiala domänen är shiftade Dirarc funktioner och i Fourier domänen komplexa exponentialfunktioner.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Ange ekvationerna för Fourier transformationen.
		</Question>
		<Answer>
			[b]Kontinuerlig[/b]
			[math]cc "F"(f(x)) = int_(x in R^n) f(x) e^(- i omega^T x) dx = hat(f) (omega)[/math]
			[math]cc "F"^-1(hat(f) (x)) = 1 / (2 pi)^n int_(omega in R^n) hat(f) (x) e^(i omega^T x) d omega[/math]
			[math]e^(i omega^T x) = cos(omega^T x) + i * sin(omega^T x)[/math]

			Terminologi:
			[ul]
				[li]Frequency spectrum: [math]hat(f)(omega) = Re(omega) + i Im(omega) = |hat(f)(omega)| e^(i phi(omega))[/math][/li]
				[li]Fourier spectrum: [math]|hat(f)(omega)|=sqrt(Re^2(omega) + Im^2(omega))[/math][/li]
				[li]Power spectrum: [math]|hat(f)(omega)|^2[/math][/li]
				[li]Phase angle: [math]phi(omega)=arg hat(f) (omega) = tan^-1 ((Im(omega)) / (Re(omega)))[/math][/li]
				[li]Angular frequency: [math]omega = (omega_1, omega_2)^T[/math], [math]omega_1[/math] i x riktning, [math]omega_2[/math] i y riktning[/li]
				[li]Frequency: [math]f = omega / (2 pi)[/math][/li]
				[li]Wavelength: [math]lambda = (2 pi) / ||omega||[/math][/li]
			[/ul]Alternativ representation: Fourie koefficienterna [math]hat(f) (omega_1, omega_2)[/math] är komplexa tal, med det är inte uppenbart vad reella och imaginära delarna representerar. Ett annat sätt är att representera det med fas och magnitude.
			[ul]
				[li]Magnitude: [math]|hat(f)(omega_1, omega_2)| = sqrt(Re^2(omega_1, omega_2) + Im^2(omega_1, omega_2))[/math][/li]
				[li]Phase: [math]phi(omega_1, omega_2) = tan^-1 ((Im(omega_1, omega_2)) / (Re(omega_1, omega_2)))[/math][/li]
			[/ul]Det gäller även att sinusoids och cosinusoids är egenfunktioner av faltningar.

			[b]Diskret[/b]
			[math]hat(f)(u, v) = 1 / sqrt(MN) sum_(m=0)^(M-1) sum_(n=0)^(N-1) f(m, n) e^(-2 pi i ((m u) / M + (n v) / N))[/math]
			[math]f(m, n) = 1 / sqrt(MN) sum_(u=0)^(M-1) sum_(v=0)^(N-1) hat(f)(u, v) e^(+2 pi i ((m u) / M + (n v) / N))[/math]

			Terminologi:
			[ul]
				[li]Fourier spectrum: [math]|F(u, v)|=sqrt(Re^2(u, v) + Im^2(u, v))[/math][/li]
				[li]Phase angle: [math]phi(u, v) = tan^-1 ((Im(u, v)) / (Re(u, v)))[/math][/li]
				[li]Power spectrum [math]P(u, v) = |F(u, v)|^ 2 = Re^2(u, v) + Im^2(u, v)[/math][/li]
				[li]Magnitude: är största värdet.[/li]
				[li]Phase: anger origo, där sinusoiden börjar.[/li]
			[/ul][b]Relation[/b]
			I 1D så är relationen mellan diskret och kontinuerlig [math]omega = (2 pi u) / M[/math]. Detta innebär att [math]u in [0, M - 1][/math] och [math]omega in [0, 2 pi)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad säger faltningssatsen?
		</Question>
		<Answer>
			Att faltning i den spatiala domänen är samma sak som multiplikation i Fourier domänen (omvänt gäller också).
			[math]cc "F" (h ** f) = cc "F"(h) * cc "F"(f), cc "F"(f * g) = cc "F"(f) ** cc "F"(g)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad innebär det att ett filter är separerbar?
		</Question>
		<Answer>
			Det innebär att en kernel i 2D [math]h(x, y)[/math] kan delas som en serie av 1D faltningar. 
			Dvs: Om [math]hat(f)(u, v) = 1 / sqrt(M N) sum_(m=0)^(M-1) sum_(n=0)^(N-1) f(m, n) e^(-2 pi i ((m u) / M + (n v)/N))[/math] så kan den skrivas som: [math]hat(f)(u, v) = 1 / sqrt(M) sum_(m=0)^(M-1) (1 / sqrt(N) sum_(n=0)^(N-1) f(m, n) e^(-2 pi i (n v) / N)) e^(-2 pi i (m u) / M)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Ange olika egenskaper för Fourier transformationen.
		</Question>
		<Answer>
			[b]Linjäritet[/b]
			[math]cc "F" [a f_1(m, n) + b f_2(m, n)] = a hat(f)_1(u, v) + b hat(f)_2(u, v)[/math]
			[math]a f_1(m, n) + b f_2(m, n) = cc "F"^-1 [a hat(f)_1(u, v) + b hat(f)_2(u, v)][/math]

			[b]Modulation[/b]
			[math]cc "F" [f(m, n) * e^(2 pi i ((m u_0) / M + (n v_0) / N))] = hat(f)(u - u_0, v - v_0)[/math]. Detta innebär att origo för Fourie transformen kan flytas till mitten av bilden genom att multiplicera med [math](-1)^(m + n)[/math].

			[b]Translation[/b]
			Om bilden flyttas, så genomgår Fourier spektrumet en fasförskjutning, men magnituden av spektrumet är den samma.
			[math]cc "F"[f(m - m_0, n - n_0)] = hat(f)(u, v) e^(-2 pi i ((m_0 u) / M + (n_0 v) / N))[/math]
			[math]|hat(f)(u, v) e^(-2 pi i ((m_0 u) / M + (n_0 v) / N))| = |hat(f)(u, v)|[/math]

			[b]Rotation[/b]
			Om bilden roteras med en vinkel [math]alpha[/math], så roteras Fourier transformationen med samma vinkel.

			[b]Skalning[/b]
			Komprimering i den spatiala domänen är samma sak som expansion i Fourie domänen (och tvärtom).

			[b]Periodisk[/b]
			Den diskreta fourier transformen och dess invers är periodisk, med en period [math]N[/math] för en [math]N xx N[/math] bild. Alltså: [math]hat(f)(u, v) = hat(f)(u + N, v) = hat(f)(u, v + H) = hat(f)(u + N, v + N)[/math]. Detta innebär att [math]hat(f)[/math] återupprepar sig oändligt. Det krävs dock endast en period för att återskapa original funktionen [math]f[/math].

			[b]Konjugat symmetri[/b]
			Fourier transformen uppfyller [math]hat(f)(u, v) = hat(f)^(**)(-u, -v)[/math] och [math]|hat(f)(u, v)|=|hat(f)(-u, -v)|[/math]. Om vi använder att [math]hat(f)[/math] är periodiskt och är symmetriskt runt origo, får vi att vi inte behöver [math]2N^2[/math] (hälften för reella delen och hälften för imaginära) värden för att representera en [math]N xx N[/math] bild i Fourier domänen, utan [math]N^2[/math] om vi använder symmetrin.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Ange våglängden och perioden för en 2D sinusoid.
		</Question>
		<Answer>
			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/Wavelength.png[/img]
		</Answer>
	</TestQuestion>
	<!-- Någon on transfer funktioner? -->
	<TestQuestion Category="FourierTransform">
		<Question>
			Ange vad sampling innebär för Fourier transformer.
		</Question>
		<Answer>
			Signalerna (bilderna) är ej kontinuerliga, men diskreta. En kontinuerlig funktion [math]f(x, y)[/math] kan då samplas ett diskret rutnät av sampling punkter.
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/Sampling.png[/img]
			Där [math]Delta x, Delta y[/math] kallas för sampling intervallen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Hur kan sampling beskrivas mer formellt?
		</Question>
		<Answer>
			Vi beskriver den ideala impulsen m.h.a Dirarc distributionen:
			[math]int_(-\infty)^(infty) int_(-infty)^(infty) delta(x, y) dx dy = 1[/math] och [math]delta(x, y) = 0[/math] för alla [math]x, y != 0[/math].

			"Sifting" egenskapen av Dirac funktionen ger då ett värde för funktionen [math]f(x, y)[/math] vid punkten [math](a, b)[/math]: [math]int_(-\infty)^(infty) int_(-infty)^(infty) f(x, y) delta(x - a, y - b) dx dy = f(a, b)[/math].

			Den ideala samplingen [math]s(x, y)[/math] i ett rutnät kan då beskrivas som en samling av Dirac funktioner [math]delta[/math]: [math]s(x, y) = sum_(j=1)^M sum_(k=1)^N delta(x - j Delta x, y - k Delta y)[/math]. Då är den samplade bilden [math]f_s(x, y)[/math] en produkt av den kontinuerliga bilden [math]f(x, y)[/math] och sampling funktionen [math]s(x, y)[/math].

			[math]f_s(x, y) = f(x, y) s(x, y)[/math]
			[math] = f(x, y) sum_(j=1)^M sum_(k=1)^N delta(x - j Delta x, y - k Delta y)[/math]
			[math] = sum_(j=1)^M sum_(k=1)^N  f(j Delta x, k Delta y) delta(x - j Delta x, y - k Delta y)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad för fel kan uppstå vid sampling?
		</Question>
		<Answer>
			[ul]
				[li]Intensity quantization: inte tillräckligt med upplösning för intensiteten.[/li]
				[li]Spatial aliasing: inte tillräckligt med spatial upplösning.[/li]
				[li]Temporal aliasing: inte tillräckligt med temporal upplösning.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad är aliasing?
		</Question>
		<Answer>
			Det är artefakter som produceras av under-sampling eller en dålig omkonstruktion. Detta innebär att bilden ser pixelig ut. Detta löses med anti-aliasing.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Ange olika sätt att göra anti-aliasing
		</Question>
		<Answer>
			[ul]
				[li]Öka hastigheten vi samplar med (dock inte möjligt i praktiken)[/li]
				[li]Minska högsta frekvensen förre sampling, vilket görs med blurring.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="FourierTransform">
		<Question>
			Vad säger sampling satsen?
		</Question>
		<Answer>
			[ul]
				[li]En signal säges vara band begränsad om dess högsta frekvens är begränsad. Denna frekvens kallas för bandbredden (bandwidth).[/li]
				[li]Sinus/cosinus komponenten av den högsta frekvensen anger den högsta frekvens innehållet för signalen.[/li]
				[li]Om signalen samplas med en hastighet som är samma, eller mer än två gånger så stor som den högsta frekvensen, så kan original signalen återskapas komplett från samples.[/li]
				[li]Den lägsta sampling hastigheten för en band begränsad funktion kallas för dess Nyquist hastighet.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<!-- degradation vs restoration -->
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad för krav brukar vi ställa på en transformation [math]s = T(r)[/math]?
		</Question>
		<Answer>
			[ul]
				[li][math]T(r_text(min))=r_text(min)[/math], [math]T(r_text(max))=r_text(max)[/math] (eller omvänt). Detta innebär att vi fyller upp hela intervallet av värden.[/li]
				[li][math]T[/math] är monotonisk, vilket innebär att den också är inverterbar (vi tappar ingen information).[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad innebär en Look-Up Table (LUT)?
		</Question>
		<Answer>
			Det innebär att vi har sparat en tabell, som mappar ifrån input till utvärdet, istället för att beräkna funktionen direkt.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad innebär en log transformation?
		</Question>
		<Answer>
			Det innebär att vi applicerar funktionen [math]s = c log (1 + r)[/math]. Den är användbar för att komprimera stor "dynamic range" och för att göra detaljer synliga.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad innebär power-law transformation?
		</Question>
		<Answer>
			Det innebär att vi applicerar funktionen [math]s = c r^gamma[/math] eller [math]s = c (r + epsilon)^gamma[/math]. Många enheter som används för kameror, printning och skärmar lyder under en sådan lag.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad innebär histogram stretching?
		</Question>
		<Answer>
			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/HistogramStretching.png [/img]

			Det innebär att vi ökar konstrasten genom att låta intervallet [math][c, d][/math] täcka hela bilden. Detta innebär att vi tappar information i området [math][a, b][/math] och [math][d, b][/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad innebär histogram equalization?
		</Question>
		<Answer>
			Idén är att vi omdistribuera gråskala värdena så jämnt som möjligt. Detta skulle motsvara en distribution av ljussättning där alla värden är lika sannolika.

			Detta går till så att vi först beräknar ett histogram över pixelvärden för bilden. Sen sparar vi den kumulativa summan av alla histogram värden och normaliserar varje värde genom att dela med antalet pixlar. Detta använder vi sen för att transformera bilden.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Ange olika typer av linjära filter som används för att förbättra bilder.
		</Question>
		<Answer>
			[ul]
				[li]Lowpass: eliminera komponenter med hög frekvens (kanter och skarpa detaljer). Detta leder till att bilden blir suddig.[/li]
				[li]Highpass: eliminera komponenter med låg frekvens (saker som varierar sakta, t.ex. skuggning). Detta leder till att kanter och andra detaljer (även brus) blir mer skarpa.[/li]
				[li]Bandpass: eliminera komponenter som ligger utanför ett frekvensområdet. Detta leder en kombination av low- och highpass.[/li]
			[/ul][img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/LinearFiltersImageEnhancement.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Ange olika typer av brus.
		</Question>
		<Answer>
			[ul]
				[li]Signal oberoende additivt brus (sampling brus): [math]g = f + nu[/math].[/li]
				[li]Signal beroende multiplikativt brus (ljussättnings variation): [math]g = f + nu f = (1 + nu) f[/math].[/li]
				[li]Uppmättningsbrus (salt och peppar)[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Hur fungerar mean filtering?
		</Question>
		<Answer>
			Detta innebär att vi ett nytt pixelvärde som ett medelvärde för ett område runt pixeln. Detta görs lättast med en kernel, t.ex.: [math]1 / 9 [[1, 1, 1], [1, 1, 1], [1, 1, 1]][/math]. Själva kerneln kan variera, men den bör uppfylla:
			[ul]
				[li]Koefficienterna summerar till 1.[/li]
				[li]Symmetriskt upp/ner och vänster/höger.[/li]
				[li]Center pixeln har störst inverkan.[/li]
				[li]Filtret bör vara separerbar.[/li]
			[/ul]Ett filter som uppfyller detta är: [math]C=(((Delta t) / 2), (1 - Delta t), ((Delta t) / 2)) (((Delta t) / 2, 1 - Delta t, (Delta t) / 2))[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad är ett ideellt low pass filter?
		</Question>
		<Answer>
			Det är en filter som är ideellt i frekvensdomänen, men inte ideellt i den spatiala domänen. Detta ger ringar/suddiga bilder.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad är ett Gaussian low-pass filter?
		</Question>
		<Answer>
			Det är ett filter som använder en normalfördelning, med kvadrerade avståndet ifrån origo. En lägre varians ger en högre "cutoff" frekvens och en mildare filtering.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad är en Binomial kernel?
		</Question>
		<Answer>
			Det är en typ av filter som använder sig av binomialkoefficienter. När vi ökar storleken, så närmar vi oss en Gaussian kernel.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad innebär Anisotropic smoothing?
		</Question>
		<Answer>
			Det innebär att vi smoothar olika i olika riktningar, för att bevara kanter. Idén är att vi smoothar pixlar baserad på en likhet mellan pixlar, där den t.ex. kan vara i färg eller position.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Vad innebär median filtering?
		</Question>
		<Answer>
			Det innebär att vi filtrerar baserat på medianen i ett område. Fördelarna är att den bevarar skuggor, skarpa kanter, eliminerar lokala extremvärden (t.ex. salt och peppar brus), men ger att bilden ser ut som en målning.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Hur kan vi beräkna derivatan av en bild?
		</Question>
		<Answer>
			[b]Första ordningen[/b]
			[math]f_x = f(x + 1, y) - f(x, y)[/math]. Detta representeras av [math][[0, -1, 1]][/math]. Men i pratiken så används central differans: [math]f_x = 1 / 2 (f(x + 1, y) - f(x - 1, y)) => 1/2 [[-1, 0, 1]][/math].

			[b]Andra ordningen[/b]
			[math]f_(x x) = f(x + 1, y) + f(x - 1, y) - 2f(x, y) => [[1, -2, 1]][/math].

			[b]Gradienten[/b]
			[math]nabla f = (f_x, f_y)[/math]

			[b]Magnituden av Gradienten[/b]
			[math]|nabla f| = sqrt(f_x^2 + f_y^2)[/math]

			[b]Laplacian[/b]
			[math]nabla^2 f = f_(x x) + f_(yy)[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Bildförbättring">
		<Question>
			Hur kan vi göra en bild skarpare?
		</Question>
		<Answer>
			[b]Unsharp masking[/b]
			Idén är att vi vill subtraherar bort suddigheten ifrån bilden. Låt [math]bar(f)(x, y)[/math] vara en suddad version av bilden. Då fungerar det: [math]g(x, y) = f(x, y) + alpha(f(x, y) - bar(f)(x, y))[/math].

			[b]Highpass filtering[/b]
			[math]G(u, v) = F(u, v) + alpha(H_text(hp)(u, v) F(u, v))[/math]
			där [math]H_text(hp)(u, v)[/math] kan vara: 
			Ideellt: [math]H_text(hp)(u, v) = { (1, text(om ) (u^2+v^2) > D_0^2), (0, text(annars)) :}[/math].
			Gaussian: [math]H_text(hp)(u, v) = 1 - e^((-sigma^2 (u^2+v^2))/2)[/math].

			[b]Derivering[/b]
			M.h.a Laplacian: [math]g(x, y) = f(x, y) - nabla^2 f(x, y)[/math]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ShapeRepresentation">
		<Question>
			Vad används Hough transformen till?
		</Question>
		<Answer>
			Den används för att hitta alla möjliga linjer för en mängd av kanter. En linjes styrka beror på hur många punkter som ligger på den linjen.

			Vi introducerar då accumulator rymden, som innehåller antalet röster för varje linje. Rymden består av linjer på formen: [math]L(k)=-kx+y[/math]. Men på grund av att vertikala linjer repesenteras av linjer med [math]k \rightarrow pm \infty[/math] använder vi istället en annan representation: [math]x cos(theta) + y sin(theta) = r[/math] där [math]r[/math] är det vinkelrätta avståndet ifrån origo och [math]theta[/math] vinkeln mellan vektorn [math]bar r[/math] och origo.

			[img width="75%" height="75%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/HoughTransform.png[/img]

			Hough transformen kan även utökas för att hitta cirklar (3D) och ellipser (5D). Men detta blir mycket ineffektivt att beräkna.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ShapeRepresentation">
		<Question>
			Vad är RANSAC?
		</Question>
		<Answer>
			RANSAC står för Random Sampling Consensus, och likt Hough transformen kan den hitta linjer, cirklar, ellipser, etc. 

			[ol]
				[li]Välj slumpmässigt ut ett minimalt antal punkter, 2 för linjer, 3 för cirklar och 5 för ellipser.[/li]
				[li]Beräkna en model (t.ex. [math]y=kx+L[/math]) ifrån punkterna.[/li]
				[li]Beräkna antalet punkter som är nära till modellen.[/li]
				[li]Uppreppa steg 1-3 [math]S[/math] gånger.[/li]
				[li]Välj den lösning med flest antalet matchande punkter.[/li]
			[/ol]För att avgöra hur många iterationer [math]S[/math] som behövs kan man resonera följande: Hur många iterationer behövs för att med en sannolikhet [math]P[/math], om [math]p[/math] % av punkterna tillhör formen? Då får man formeln: [math]S = log(1 - P) / log(1 - p^K)[/math].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ShapeRepresentation">
		<Question>
			Vad innebär homografi (homography)?
		</Question>
		<Answer>
			Två bilder ifrån samma plana yta relaterad genom en homografi. Detta kan användas för att transformera en punkt i en kamera till en annan kamera, och punkterna ligger på ett gemensamt plan.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ShapeRepresentation">
		<Question>
			Vad för olika typer invarianser vill vi ha för representation av former?
		</Question>
		<Answer>
			[ul]
				[li]Förflyttning[/li]
				[li]Skala[/li]
				[li]Rotation (dock inte alltid, t.ex. 6 och 9)[/li]
				[li]Spegling[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ShapeRepresentation">
		<Question>
			Ange olika enklare representationer av former.
		</Question>
		<Answer>
			[ul]
				[li]Sammanhängande komponenter, med egenskaperna: storlek, bounding box, center of gravity.[/li]
				[li]Compactness: [math]text(area)/text(circumference)^2[/math][/li]
				[li]Eccentricity: [math]text(length of maximum chord A)/text(length of maximum chord B⊥A)[/math][/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ShapeRepresentation">
		<Question>
			Vad är moments?
		</Question>
		<Answer>
			[math]m_(pq)=int int_(Omega) x^p y^q f(x, y) dx dy[/math] där [math]f(x, y) = { (1, text(inom regionen)), (0, text(annars)) :}[/math]. Vi har också centered moments [math]mu_(pq) int int_(Omega) (f - bar(x))^p (y - bar(y))^q f(x, y) dx dy[/math] med center of gravity: [math]bar(x) = m_10 / m_00, bar(y) = m_01 / m_00[/math].

			Notera att [math]m_00[/math] anger arean för regionen.
			<!-- Något om ellips approxmation? -->
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ShapeRepresentation">
		<Question>
			Vad är PCA?
		</Question>
		<Answer>
			PCA står för [i]principal components analysis[/i], och används för att reducera dimensionen på datan. Idén bakom PCA är att vi antar att den största delen av information finns i de riktningar som varierar mest.

			Låt [math]K[/math] vara dimensionen för den nya datan och [math]N[/math] dimensionen för original datan.

			[b]Hitta en bas[/b]
			Antag att [math]x_1, x_2, ..., x_M[/math] är [math]N xx 1[/math] vektorer.
			[i]Steg 1[/i]
			[math]bar(x) = 1 / M sum_(i=1)^M x_i[/math]

			[i]Steg 2[/i]
			[math]Phi_i = x_i - bar(x)[/math]

			[i]Steg 3[/i]
			Bilda: [math]A = [[Phi_1, Phi_2, ..., Phi_M]][/math].
			Beräkna [math]C = 1 / M sum_(i=1)^M Phi_i Phi_i^T A A^T[/math] (kovariansmatris, [math]N xx N[/math])

			[i]Steg 4[/i]
			Beräkna egenvärdena av [math]C[/math]: [math]lambda_1 > lambda_2 > ... > lambda_N[/math].

			[i]Steg 5[/i]
			Beräkna egenvektorerna av [math]C[/math]: [math]u_1, u_2, ..., u_n[/math]. Dessa vektorer bildar en bas för [math]x - bar(x)[/math].
			[math]x - bar(x) = b_1 u_1 + b_2 u_2 + ... + b_N u_N = sum_(k=1)^N b_k u_k, b_k = u_k^T (x - bar(x))[/math]

			[i]Steg 6[/i]
			Behåll endast de termer med de [math]K[/math] högsta egenvärdena.
			[math]x - bar(x) = sum_(k=1)^K b_k u_k[/math]

			[b]Approximera datan[/b]
			Detta görs genom att projicera vektorerna till den lägre dimensionen: [math]bar(x) = b_1 u_1 b_2 u_2 + ... + b_K u_K[/math].

			Detta fungerar även för bilder, om vi gör om varje bild till en lång vektor istället.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Vad innebär bildsegmentering (image segmentation)?
		</Question>
		<Answer>
			Det innebär att vi delar in bilden i semantiskt meningsfulla regioner.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Varför bör man ta hänsyn till Spatial coherence?
		</Question>
		<Answer>
			Metoder som baseras på histogram tar ej hänsyn till beroendet mellan närliggande pixlar. Detta kan leda till segment delas upp i olika delar. Om man tar hänsyn till spatial sammanhållning mellan pixlarna, så kan detta undvikas
		</Answer>
	</TestQuestion>
	<!-- Något om Gestalt Theory? -->
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Hur fungerar thresholding?
		</Question>
		<Answer>
			Det fungerar så att vi sätter en gräns, och alla värden som är över gränsen tillhör ena segment, alla värden under gräsen, det andra segementet. För att automatiskt hitta en gräns så kan vi använda oss av olika metoder:

			[b]P-tile[/b]
			Använd tidigare information om storleken av objektet, antag att objeketet har en [math]P %[/math] storlek av hela bilden. Välj då gränsen så att [math]P %[/math] av histogramet täcks.

			[b]Mode[/b]
			Hitta lokala maximum och minimum i bilden. Sätt gränsen att vara pixelvärdet av dessa maximum/minumum.

			[b]Iterativ[/b]
			Starta med ett approxmativt gräns och förbättra det iterativt genom att ta hänsyn till någon typ av betygsättning, t.ex.: [math]T = (r_1 + r_2) / 2[/math] där [math]r_i[/math] är medelvärdet av den tidigare segmenterade regionen [math]i[/math].

			[b]Adaptive[/b]
			Dela upp bilden i delbilder, och bestäm en gräns för varje delbild.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Hur fungerar K-means?
		</Question>
		<Answer>
			Den grupperar pixlar baserat på likhet (t.ex. färg).
			[ol]
				[li]Välj [math]K[/math] antal initialvärden för klusteren.[/li]
				[li]Tilldela för varje pixel de kluster som den är närmast.[/li]
				[li]Uppdatera centret för klustret m.h.a tilldelade pixlarna.[/li]
				[li]Fortsätt tills dess att kluster centren konvergerar.[/li]
			[/ol]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Hur fungerar mean-shift segmentering?
		</Question>
		<Answer>
			Vi försöker gruppera pixlarna baserat både på färg och position. Vi låter varje pixel representeras av en 5D vektor: [math]bar(x) = [[x, y, R, G, B]][/math]. För att hantera att varje pixel är brusig, så placerar vi en "skål" runt varje pixel: [math]K(x-x_i)[/math].

			Vi vill hitta maximum av: [math]f(x) = 1 / n sum_(i=1)^n K(x-x_i)[/math] där [math]K(x) = C K(||x||^2)[/math]. Då beräknar vi gradienten som: [math]nabla f(x) = C / n sum_(i=1)^n (x-x_i) k'(||x-x_i||^2)[/math]. Vi sätter den till 0 och får då [math]x^text(new) = (sum_(i=1)^n x_i k' (||x-x_i||^2)) / (sum_(i=1)^n k'(||x-x_i||^2))[/math].

			Om vi startar på en specfik pixel, och utför ovan, så konvergerar mot någon av bildens mode. Klustra bilden baserat på vilket mode som punkten konvergerar emot.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Hur kan man förbättra en segmentering?
		</Question>
		<Answer>
			Genom att slå ihop regioner som är lika och är grannar. Det går även att dela på regioner, och variationen är för stor inom regionen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Hur fungerar watershedding?
		</Question>
		<Answer>
			[ol]
				[li]Skapa en topologiskt karta över bilden (t.ex. med magnituden av gradienten eller distanstransform)[/li]
				[li]Gradvis fyll i "bassänger" med vatten, börja med den djupaste först.[/li]
				[li]När två "bassänger" möts, skapa en kant mellan dessa två segment.[/li]
				[li]Avsluta när varje pixel antigen är fylld eller är en kant.[/li]
			[/ol]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Hur kan grafteori användas för bildsegmentering?
		</Question>
		<Answer>
			Vi låter varje pixel representera ett hörn i grafen. Pixlar som är grannar är sammankopplade med kanter, och dessa kanter har vikter. Vikterna beror vad för något som algoritmen kollar efter som t.ex. skillnad i intensitet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Vad innebär en affinity matris?
		</Question>
		<Answer>
			Vi bildar en matris, där varje element [math](p, q)[/math] anger hur lika två punkter [math]p[/math] och [math]q[/math] är. Man kan t.ex. kolla på skillnad i intensitet, avstånd eller färg.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="ImageSegmentation">
		<Question>
			Hur fungerar Normalized cuts?
		</Question>
		<Answer>
			Vi vill minimera följande funktion: [math]Ncut(A, B) = (cut(A, B)) / (assoc(A, V)) + (cut(A, B)) / (assoc(B, V))[/math].

			Låt [math]A[/math] och [math]B[/math] vara två disjunkta mängder.

			Då anger [math]cut(A, B)[/math] summan av vikterna för kanterna i snittet mellan [math]A[/math] och [math]B[/math], och [math]assoc(A, V)[/math] summan av vikterna inom mängden [math]A[/math], och på samma sätt för [math]assoc(B, V)[/math].

			Segmentering kan hittas genom att lösa ett generaliserat egenvärdesproblem.

			Det som algoritmen optimerar efter är likheten inom varje mängd ([math]A, B[/math]) ska bli så stor som möjligt, medans den minimerar likheten mellan kanter i snittet.
		</Answer>
	</TestQuestion>
</Test>
