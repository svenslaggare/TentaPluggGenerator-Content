<?xml version="1.0" encoding="utf-8" ?>
<Test Name="Tenta">
	<TestQuestion Category="Allmänt">
		<Question>
			Hur fungerar ett systemanrop?
		</Question>
		<Answer>
			Det fungerar så att man lägger argumenten i register/på stacken och även ett nummer, som pekar ut systemetanropet. Sedan utförs en TRAP-instruktion, som genererar ett mjukvaru avbrott. Detta avbrott fångas sedan upp av avbrottsrutinen.

			När operativsystemet har kontrollerat att det faktiskt var ett systemanrop (avbrott kan genereras inte endast vid systemanrop) så byter (normalt sätt) den anropande processen till en kärn-stack och forsätter att exekvera systemanropet i kärnan (även känt som supervisor mode).

			När systemanropet är klart, så byter man tillbacka till användarstacken och exekeverar som vanligt i användarläge.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			Vad är en process?
		</Question>
		<Answer>
			En process är ett program under exekvering.
			En process brukar innehålla följande information:
			[ul]
				[li]Kod (även känt som "text").[/li]
				[li]Data (globala variabler, BSS, stack, heap).[/li]
				[li]Registerinnehåll (som t.ex. programräknaren).[/li]
				[li]Fildeskriptorer (dvs öppna filer).[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			Varför används processmodellen?
		</Question>
		<Answer>
			På grund av att ett program under körning har inkapslats av en process så blir det lättare att tillåta multiprogrammering, dvs att flera program kör "samtidigt". Det ger även bättre feltolerans vilket innebär att om en process kraschar så behöver ej hela operativsystemet krascha.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			Hur skapas nya processer i UNIX-system?
		</Question>
		<Answer>
			Nya processer skapas med hjälp av systemanropet [i]fork()[/i] vilket skapar en kopia av den körande processen. Den nya barnprocessen, ärver alla öppna fildeskriptorer ifrån föräldern, syftet med detta är att möjliggöra kommunkation mellan dem via filer och pipes.
			
			Vanligtvist vill man att en den nya processen kör ett annat program, vilket görs med systemanrop ur familjen [i]exec[/i] vilket byter ut det nuvarande programmet emot ett annat.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			På vilka sätt kan en process terminera?
		</Question>
		<Answer>
			En process kan termineras på fyra sätt:
			[ul]
				[li]Normalt programslut (frivilligt)[/li]
				[li]Med fel som programmet upptäckt (frivilligt)[/li]
				[li]Fatalt fel (ofrivilligt)[/li]
				[li]Dödas av en annan process[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			Vad är skillnaden mellan en förgrundsprocess och bakgrundsprocess (i UNIX)?
		</Question>
		<Answer>
			En process som körs i förgrunden är den process som man arbetar interaktivt med, något man inte gör med en bakgrundsprocess. Det går även att se det som att när en process körs i förgrunden finns det en annan process (föräldern) som väntar på att den ska avslutas. Det finns det inte när den körs i bakgrunden.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			Vad är en "daemon" i UNIX?
		</Question>
		<Answer>
			Det är en bakgrundsprocess. Dessa processer utför oftast systemåtgärder.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			Ange de tillstånd som en process kan vara i.
		</Question>
		<Answer>
			Det finns tre tillstånd: running, blocked och ready.
			[img width="50%" height="50%"]https://dl.dropboxusercontent.com/u/4940720/TentaPluggGenerator/images/ProcessStates.png[/img]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			Vad för abstraktion används för att hålla reda på processer i systemet?
		</Question>
		<Answer>
			En så kallad [i]processtabell[/i] där varje process blir en post i tabellen som kallas för Process Controll Block (PCB). Information som lagras i denna post är process-ID (pid), prioritet, tillstånd, register, text, data, m.m.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Processer">
		<Question>
			Vad är en "zombie-process"?
		</Question>
		<Answer>
			Det är en process som har körts klart, men som fortfarande har en post i processtabellen. Varför en process som har terminerat inte tas bort direkt ifrån processtabellen är att man vill göra det möjligt för föräldrarprocesser att veta varför en barnprocess terminerade. Posten frigörs genom att anropa [i]wait[/i] på processen som terminerade.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Schemaläggning">
		<Question>
			Ange olika mål för olika typer av system när det kommer till schemaläggning.
		</Question>
		<Answer>
			[b]Allmänt[/b]
			[ul]
				[li]Rättvis.[/li]
				[li]Implementera policy.[/li]
				[li]Balans – alla delar av systemet ska utnyttjas.[/li]
			[/ul][b]Batchsystem[/b]
			[ul]
				[li]Maximera throughput.[/li]
				[li]Minimera turnaround-tid.[/li]
				[li]Maximera utnyttade av CPUn.[/li]
			[/ul][b]Interaktiva system[/b]
			[ul]
				[li]Minimera responstiden.[/li]
				[li]Proportionalitet – möt användarens förväntningar.[/li]
			[/ul][b]Realtidssystem[/b]
			[ul]
				[li]Klara deadlines[/li]
				[li]Förutsägbarhet[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Schemaläggning">
		<Question>
			Hur fungerar Shortest Job First (SJF) som schemaläggningsalgoritm?
		</Question>
		<Answer>
			Om vi i [b]förväg[/b] vet hur lång tid varje process kommer att exekvera så kan SJF användas. Då ordnar man processerna i ordning från processer med kortaste exekveringstid till processer med längst. Denna algoritm är optimal med avseende på kortast medelsluttid. Det är även bra om man i förväg känner till alla jobb som ska utföras, så det inte dyker upp nya med tiden. Om så är fallet kan [i]svältning[/i] uppstå om korta jobb hela tiden kommer in och lägger sig innan de längre jobben.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Schemaläggning">
		<Question>
			Vad är avbrytade schemaläggning (preemptive scheduling)?
		</Question>
		<Answer>
			Det är när en exekverande provess kan avbrytas (dvs gå från tillståndet running till ready) utan att processen själv har bett om det. En process kan avbrytas t.ex. om den kört för länge/förbrukat sitt tidskvanta eller om en process med högre prioritet blir körbar.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Schemaläggning">
		<Question>
			Vad innebär en context switch?
		</Question>
		<Answer>
			Det innebär att vi sparar tillståndet för en process eller tråd så att exekveringen kan fortsätta vid ett senare tillfälle. Sedan byter vi till en annan process genom att återställa tillståndet för processen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Schemaläggning">
		<Question>
			Hur fungerar schemaläggning med tidsdelning (time-slicing)?
		</Question>
		<Answer>
			Det innebär att alla processer får en viss tid som de får köra, t.ex. 100 ms. Alla processer som är i tillståndet READY ligger i den så kallade [i]ready-kön[/i]. Efter en process har körts så läggs den sist i ready-kön och den som ligger först får köra. Den tid som en process får köra kallas för [i]time slice[/i] eller [i]tidskvanta[/i]. För att uppnå bra prestanda krävs en rimlig relation mellan en time slice och tiden för en context-switch.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Schemaläggning">
		<Question>
			Vad innebär svältning när det kommer till schemaläggning?
		</Question>
		<Answer>
			Det innebär att en process(er) [i]aldrig[/i] får köra för att andra processer har högre prioritet. Detta kan t.ex. lösas genom att ge processer som fått vänta längre högre prioritet temporärt.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Schemaläggning">
		<Question>
			Vad innebär policy och mekanism när det kommer till schemaläggning?
		</Question>
		<Answer>
			Mekanismen är hur schemaläggningen utförs medans policy bestämmer vilka processer som ska schemaläggas. T.ex. om vi har en pre-emptiv schemaläggning som baseras på prioriteter så är mekanismen att schemaläggaren alltid ser till att den process som har högst prioritet får exekevera. Policyn är då hur prioriteterna anges för processerna.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär dynamisk laddning och dynamisk länkning?
		</Question>
		<Answer>
			Dynamisk laddning innebär att ett program (eller bibliotek) laddas in i den nuvarande processens minne [b]efter den har startat[/b].
			Dynamisk länkning innebär att mapping av namn till adress för symboler sker [b]efter kompilering[/b].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär en fysik och en logisk adressrymd?
		</Question>
		<Answer>
			En fysisk adressrymd är de faktiska minnespositionerna i datorns fysiska primärminne.
			En logisk adressrymd är en abstrakt adressrymd som programmet använder, vilket mappas till den fysiska adressrymden. Ett annat namn är en [i]virtuell adressrymd[/i].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär relokerbar kod?
		</Question>
		<Answer>
			Det innebär att adresser anges relativt något, vanligtvist början av programmet. De relativa adresserna binds till en absolut adress när vi vet var programmet ska laddas in. Dessa tillfällen är:
			[ul]
				[li]Compile-time[/li]
				[li]Load-time[/li]
				[li]Run-time[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär fragmentering?
		</Question>
		<Answer>
			Det finns två typer av fragmentering:
			
			[b]Extern fragmentering[/b]
			Det finns ledigt utrymme, men är uppdelat i för små block (som ej är närliggande). Extern fragmentering löses med kompaktering (vilket är kostsamt) eller att endast ha en enda blockstorlek, vilket leder till intern fragmentering.

			[b]Intern fragmentering[/b]
			Dåligt utnyttjande av minne inom allokerade block. Detta löses med variabel blockstorlek, vilket leder till extern fragmentering.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Ange två sätt att hålla reda på ledigt minne.
		</Question>
		<Answer>
			[b]Länkande listor[/b]
			Elementen i listan består av hål (ledigt utrymme) som innehåller: Startadress, storlek och pekare till nästa element.	Hur listan skall sorteras beror på vilken allokeringsmetod som används.

			[b]Bitmap[/b]
			Minnet delas upp i lika stora "allokeringsenheter" där en bitvektor används och där 0 betyder att enheten är ledig och 1 upptagen för enhet [i]i[/i]. Val av storleken på allokeringsenheten blir då viktig. För liten innebär att bitmappen blir för stor medan en för stor leder till intern fragmentering.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär swappning?
		</Question>
		<Answer>
			Det innebär att en process flyttas mellan primärminne och disk för att ge rum till andra processer. Swap-in innebär att en process flyttas från disk till minne och swap-out innebär att en process flyttas från minne till disk.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär det att minnet är sidindelat?
		</Question>
		<Answer>
			Det innebär att minnet delas i lika stora sidor. En sida är något som finns i den virtuella minnesrymden medan en ram är en sida som finns i det fysiska minnet. Översättningen till fysisk adress sker vid körning.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Hur fungerar rättigheter (läsa/skriva/exekvera) för minnesadresser i ett sidindelat minne?
		</Question>
		<Answer>
			Rättigheterna fungerar på sidnivå. Detta innebär att t.ex. text- och data-arean [i]inte[/i] kan dela sidor. Detta beror på att vi endast vill kunna läsa och exekvera text-arean medan vi [i]inte[/i] vill kunna exekvera data-arean!
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Hur kan man undvidka att en process adressar en ram som ej ligger i dess adressrymd?
		</Question>
		<Answer>
			[ol]
				[li]Valid/invalid bit för varje post i sidtabellen.[/li]
				[li]Register som anger längden av sidtabellen.[/li]
			[/ol]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad är en TLB för något?
		</Question>
		<Answer>
			TLB står för "Translation Lookaside Buffer" och fungerar som ett cacheminne för sidtabellen som implementeras i hårdvaran (närmare bestämt MMU). En TLB mappar från ett sidnummer till ett ramnummer. Den implementeras med assocativt minne vilket innebär att det går att söka i hela minnet parallellt.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär en miss i TLBn?
		</Question>
		<Answer>
			Det innebär att den sida som efterfrågas ej finns i TLB. Detta innebär att sidtabellen som finns i primärminnet måste accessas. Efter det så uppdateras TLB (om sidan var giltig) genom att slänga ut en ogiltig eller gammal post. För de flesta arkitekturer sker hantering i MMU men i vissa arkitekturer som t.ex. SPARC sker det i mjukvara. Detta är för att TLB är en komplex del av MMU, vilket tar upp mycket utrymme i hårdvåran (som man vill undvika).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Ange olika sätt att implementera sidtabellen.
		</Question>
		<Answer>
			[b]En-nivås sidtabell[/b]
			Antag att vi har en logisk adressrymd med storleken [math]2^m[/math] och storleken på en sida är [math]2^n[/math]. Då används de [math]n[/math] första bitarna för offseten inom sidan ([math]d[/math]) och de resterande [math]m-n[/math] bitarna ([math]p[/math]) anger vilken sida det är. Då kan vi hämta (i sidtabellen) vilket ram som adressen tillhör. När vi har ramnumret och offseten, så kan den fysiska adressen pekas ut.

			[b]Fler-nivåers sidtabell[/b]
			Då består sidtabellen av flera nivåer. Syftet med en fler-nivåers sidtabell är att undvika att allokera alla möjliga sidor för sidtabellen, vilket kan ta upp mycket utrymme och är opraktiskt för 64-bitars system. För att få en rimlig storlek på den yttersta sidtabellen krävs minst 5-7 nivåer, men detta blir istället för ineffektivt.

			Exempel:
			Antag att vi har en tvånivåers sidtabell. Om vi antar att vi har en logisk adressrymd med storleken [math]2^m[/math], sidstorleken [math]2^n[/math] och storleken på en post i sidtabellen: [math]2^e[/math]. Den inre sidtabellen kommer då att ha [math]2^(n-e)[/math] poster per sida och den yttre sidtabellen kommer då att ha [math]2^(m-2n-e)[/math] positioner. En inre sidtabell allokeras endast om det finns någon sida som används.

			[b]Hashad sidtabell[/b]
			Fungerar som en hashtabell, där vi mappar från sidnummer till en post i sidtabellen. Här kan krockar i tabellen hanteras som länkade listor, dvs alla poster med samma hash bildar en länkad list.

			[b]Inverterad sidtabell[/b]
			Om varje process har en egen sidtabell kan det gå åt mycket minne. Idén med en inverterad sidtabell är att endast ha en sidtabell för alla processer där det finns en post för varje fysisk ram. I varje post har man då [i]sidnummret + ID[/i] för processen som allokerat ramen.

			Nackdelen med denna implementation är att man måste söka i hela sidtabellen för att hitta ramen för en sida. Detta kan återgärdas genom att t.ex. hasha den inverterade sidtabellen eller att man använder sig av assocativt minne (som dock är dyrt). En annan nackdel är att det blir svårare att dela sidor mellan processer.

			[b]Hashad inverterad sidtabell[/b]
			Det är en variant av en inverterade sidtabellen, där en hash funktion används för att mappa en virtuell adress till en post i sidtabellen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad för information brukar finnas i en post i sidtabellen och TLBn?
		</Question>
		<Answer>
			[b]Ramnummer[/b]
			Vilken fysisk ram som sidan mappar till. Huvudsyftet med en sidtabell är att ta reda på detta värde för en sida.

			[b]Rättigheter[/b]
			Anger vad för åtgärder som kan utföras. De tre vanligaste rättigheterna som stöjds är: läsa, skriva och exekevera.

			[b]Modifierad[/b]
			Indikerar om sidan har blivit modifierad sedan den laddades in. En sida som har blivit modiferad brukar kallas för [b]dirty[/b] medan som inte har modifieras [b]clean[/b].

			[b]Refererad[/b]
			Indikerar som sidan har blivit refererad (skrivits/lästs) sedan sidan laddades in.

			[b]Inladdad[/b]
			Indikerar att sidan är inladdad i primärminnet. Även känt som [b]present/absent[/b].

			I TLB brukar det också finnas information som vilken process sidan tillhör och en bit som anger om sidan är giltig (valid).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär demand paging?
		</Question>
		<Answer>
			Det innebär att man lägger till information till sidtabellen som indikerar om sidan finns i primärminnet eller inte. När en sida som inte finns i primärminnet refereras så genereras ett [b]sidfel (page fault)[/b]. Vid sidfel så hämtas sidan från sekundärminnet (t.ex. disk) till primärminnet och sidtabellen uppdateras.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Ange de tre olika typerna av sidfel som finns. 
		</Question>
		<Answer>
			[b]Minor[/b]
			Det innebär att sidan är inladdad i primärminnet när sidfelet genererades, men har inte markeras i sidtabellen att den är inladdad. Det enda som krävs är att markera i sidtabellen att sidan är inladdad, ingen disk access behövs.

			[b]Major[/b]
			Det innebär att sidan inte finns i primärminnet och måste laddas in från disk.

			[b]Invalid[/b]
			Det innebär att den adressen som refererades inte är del av den virtuella adressrymden. Typisk så genereras ett segmenterings fel (segmentation fault) där detta sker.

			När det kommer till TLB används terminologin: en [b]soft miss[/b] för att indikera att sidan som refererades finns i primärminnet men inte i TLBn och [b]hard miss[/b] att sidan varken finns i TLB:n eller primärminnet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad är skillnanden mellan swapping och paging?
		</Question>
		<Answer>
			Swapping innebär att byta ut hela processer medan paging handlar om att byta ut sidor.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Vad innebär pre-paging?
		</Question>
		<Answer>
			Det innebär att vi försöker räkna ut vilka sidor som kommer att behövas och laddar in dessa i förvag.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Generellt sett, vilka två mål finns när det kommer till att byta ut sidor?
		</Question>
		<Answer>
			[ol]
				[li]Minimera antalet sidfel.[/li]
				[li]Minimera I/O.[/li]
			[/ol]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Vad är I/O-kostnaden för att byta ut sidor?
		</Question>
		<Answer>
			Det kostar mindre att byta ut en sida som inte är modifierad än en som är modifierad. Om en sida i en ram är [b]ren[/b] (ej modiferad) så finns en kopia på disk, vilket innebär att man ej behöver skriva innehållet i ramen till disk, dvs endast 1 I/O-operation krävs. Men om en ram är modifierad ([b]dirty[/b]) så måste den skrivas ut till disk innan en ny sida kan läsas in till ramen, dvs 2 I/O-operationer krävs.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Vad innebär en referenssträng?
		</Question>
		<Answer>
			Det är en sträng av sidnummer i den ordning de refereras. Om samma sida har refereras flera gånger i följd, så tas endast en med. En referenssträng kan användas för att utvärdera sidutbytesalgoritmer.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Vad är working set?
		</Question>
		<Answer>
			Det är uppsättning sidor som en process refererar, dvs behöver för att kunna exekvera under en (liten) tidsrymd [math]T[/math]. Det mest intressanta med working set är dess storlek. Om en process inte har tillgång till så många ramar som storleken på dess working set så kommer det att genereras många sidfel. 
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Hur fungerar den optimala sidutbytesalgoritmen?
		</Question>
		<Answer>
			Den sida som kommer att dröja längst innan den refereras igen kommer att bytas ut. Den är optimal med avseende på antalet sidfel och är omöjlig att implementera i praktiska system.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Hur fungerar FIFO (som sidutbytesalgoritm)?
		</Question>
		<Answer>
			Om inga lediga ramar finns så kommer den sida som har legat längst i primärminnet att bytas ut. Nackdelen med denna algoritm är att en sida som kan användas kan slängas ut. Den kan också ge fler sidfel om man [b]ökar[/b] antalet tillgängliga ramar (Belady's anomali). Den har använts i t.ex. VAX/VMS och Windows NT.

			FIFO = First In First Out.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Vad är en stackalgoritm (när det kommer till sidutbytesalgoritmer)?
		</Question>
		<Answer>
			Det är en algoritm med egenskapen att den ger färre sidfel när antalet ramar ökas. Det som är karaktäristisk för en stackalgoritm är att för varje referens i en referenssträng är den mängd av sidor som finns i primärmännet givet [math]m[/math] ramar en delmängd av den mängd sidor som finns i minnet givet [math]m+1[/math] ramar.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Hur fungerar LRU (som sidutbytesalgoritm)?
		</Question>
		<Answer>
			Den sida som det gått längst sedan den refererades kommer att bytas ut. Det är den närmaste approximation av den optimala som kan vi (enkelt) kan göra. Den är dock dyrbar att implementera för det krävs en räknare för varje instruktion som exekveras och kräver en sökning för att hitta sidan som ska slängas ut.

			LRU = Least Recently Used.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Hur fungerar Clock (som sidutbytesalgoritm)?
		</Question>
		<Answer>
			Det är en enkel approxmation av LRU genom en utvidgning av FIFO. Här införs en referens-bit i sidtabellen. Denna bit nollställs då en sida laddas in och ett ett-ställs när någon byte i sidan adresseras.

			Den fungerar så att en cirkulär lista med alla sidor i primärminnet är ordnad i FIFO-ordning. När en sida behövs bytas ut så gör man en sökning i listan och:
			[ul]
				[li]Om sidans referensbit är satt, nollställ den och sök vidare.[/li]
				[li]Första sidan med en nollställd referensbit är den sida som ska bytas ut.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Hur fungerar Clock med NRU (som sidutbytesalgoritm)?
		</Question>
		<Answer>
			Det är en förbättring av Clock-algoritmen där en modifierad-bit införs i sidtabellen. Den är från början nollställd då sidan laddas in. Den ett-ställs då man skriver till någon byte i sidan.

			Den fungerar som Clock men man väljer att byta ut en sida baserat på paret (referensbit, modifierad-bit):
			[ol]
				[li][math](0, 0)[/math] varken refererad eller modifierad.[/li]
				[li][math](0, 1)[/math] inte nyligen använd - men modifierad.[/li]
				[li][math](1, 0)[/math] nyligen använd - men inte modifierad.[/li]
				[li][math](1, 1)[/math] både nyligen använd och modifierad.[/li]
			[/ol]Används i Mac OS.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Hur fungerar Aging (som sidutbytesalgoritm)?
		</Question>
		<Answer>
			Det är en approximation av LRU. Det fungerar genom att man försöker uppskatta när en sidan senaste referades. Detta görs genom att:
			[ul]
				[li]Till varje post i sidtabellen lägg till en [i]n[/i]-bitars räknare.[/li]
				[li]Regelbundet, t.ex. vid varje klockavbrott, för alla sidor i minnet:
					[ul]
						[li]Skifta räknaren ett steg åt höger.[/li]
						[li]Addera referensbiten för sidan i den vänstra biten i räknaren.[/li]
					[/ul]
				[/li]
				[li]Vid sidfel så väljs sidan med lägst värde på räknaren att bytas ut.[/li]
				[li]Kräver sökning.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Hur fungerar WSClock (som sidutbytesalgoritm)?
		</Question>
		<Answer>
			Här försöker man göra en uppskattning av working set. Här bestämer vi en tidsrymd [math]T[/math] för vilket working set ska uppskattas. Datan om sidor i primärminnet är organiserad på samma sätt som för Clock-algoritmen.

			Det funngerar genom att man lägger till en tidsstämpel för varje post i sidtabellen och vid:
			
			[b]Uppdatering av referensbit[/b]
			Sker regelbundet som t.ex. vid varje klockavbrott vilket nollställer alla referensbitar.

			[b]Sidfel[/b]
			[ul]
				[li]Gå genom alla poster i sidtabellen.[/li]
				[li]Om referensbiten är satt: nollställ och uppdatera tidsstämpeln.[/li]
				[li]Om en sida med nollställd referensbit hittas och den referares längre tillbacka i tiden än [math]T[/math] tidsenheter, dvs den är inte längre i working set:
					[ul]
						[li]Om modifierad-biten är satt - schemalägg att sidan ska skrivas till disk och leta vidare.[/li]
						[li]Om sidan är ren - läs in den nya sidan till denna ram.[/li]
					[/ul]					
				[/li]
				[li]Om man inte hittar en ren sida som inte ligger i working set på ett varv så finns två möjligheter: 
					[ul]
						[li]En skrivning har schemalagts - fortsätta leta - till slut blir en sida ren.[/li]
						[li]Annars ersätt en godtycklig ren sida - om ingen sådan finns ta en godtycklog sida och släng ut.[/li]
					[/ul]
				[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Vad är en paging daemon?
		</Question>
		<Answer>
			Det är en process som går i bakgrunden och utför två uppgifter:
			[ul]
				[li]När I/O-enheten för att skriva sidor till sekundärminnet är ledig skriver modiferade sidor.[/li]
				[li]Om det finns för få lediga ramar så släng ut en del sidor. Information om vilken sida som låg i ramen bör även sparas så om sidan refereras och ramen ej har laddat in en annan sida så kan den återanvändas.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Varför vill man kunna "låsa" vissa sidor i minnet?
		</Question>
		<Answer>
			Det finns huvudsakligen två skäl: effektivitet och att om koden som hanterar pagning byts ut, så kan inga nya sidor laddas in.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Vad är en lokal och global sidutbytesalgoritm?
		</Question>
		<Answer>
			[b]Lokal[/b]
			Letar endast efter sidor att slänga ut hos processen som fick sidfel.

			[b]Global[/b]
			Algoritmen kan välja vilken sida som helst att slänga ut.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Vad inenbär thrashing?
		</Question>
		<Answer>
			Det innebär att en process spenderar mer tid på att byta sidor än att exekevera.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Sidutbytesalgoritmer">
		<Question>
			Vad kan vi göra för att motverka thrashing?
		</Question>
		<Answer>
			Om en process får låg sidfelsfrekvens så ta ifrån den ramar.

			[b]Lokal sidutbytesalgoritm[/b]
			Om en process får en hög sidfelfrekvens:
			[ul]
				[li]Om det finns lediga ramar: låt den allokera flera.[/li]
				[li]Om det inte finns ledia ramar: swappa ut den.[/li]
			[/ul][b]Global sidutbytesalgoritm[/b]
			Om systemet får en hög sidfelfrekvens:
			[ul]
				[li]Försök frigöra ramar.[/li]
				[li]Går det inte: swappa ut processer.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			Hur kan man öka effektiveten för anropen fork och exec i system med sidindelat minne?
		</Question>
		<Answer>
			Istället för att kopiera föräldrarprocessens sidor så kopieras endast sidtabellen. Sidorna markeras då "copy-on-write", vilket innebär att om en sida ändras av någon process så kopieras den.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Minneshantering">
		<Question>
			När fungerar virtuellt sidindelat minne dåligt?
		</Question>
		<Answer>
			Om vi har för dålig lokalitet så kan det ge följande problem:
			[ul]
				[li]Många TLB-missar - ger sämre prestanda för att varje minnesaccess som ger upphov till en TLB-miss tar ungefär dubbelt så lång tid som om vi hade fått en träff istället.[/li]
				[li]Kan också ge stort working-set vilket kan leda till många sidfel som tar lång tid att hantera (längre än en TLB-miss).[/li]
			[/ul]Om man överlastar systemet så att working-set inte ryms i minnet vilket leder till thrasing.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Ange olika accessmetoder.
		</Question>
		<Answer>
			[b]Sekvensiell access[/b]
			Man läser/skriver en följd av bytes utan möjlighet att kunna positionera sig i filen. Ett exempel är I/O mot tangentbord.

			[b]Random access[/b]
			Man kan positionera sig i filen för skriving/läsning. T.ex. som en hårddisk.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Vad för accesskontroll finns det på ett UNIX-system?
		</Question>
		<Answer>
			För varje fil/katalog så kan rättigheter anges för tre olika domäner: User, Group, Other (alla användare). Det finns tre rättigheter: [b]r[/b]ead, [b]w[/b]rite och e[b]x[/b]ecute.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Varför tillåter vi oftast inte cykler i katalogstrukturer?
		</Question>
		<Answer>
			[ul]
				[li]Det blir svårare att göra vanliga operationer som t.ex. att lista innehåller i en katalog och dess underkataloger.[/li]
				[li]Det kan behövas att man har en skräpsamlare som tar hand om filer som vi ej kan komma åt. Om cykler får existera blir detta svårare, för då bildas "delträd" i filträdet.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Vad krävs innan ett filsystem kan användas?
		</Question>
		<Answer>
			Det måste monteras.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Ange metoder för att hantera allokering av utrymme för filer.
		</Question>
		<Answer>
			[b]Kontinuerlig allokering[/b]
			Det innebär att hela filen är allokerad i en linjär sekvens av bytes. Detta kan leda till fragmentering och att det blir problematisk att hantera filer som växer i storlek. Det används dock för filsystem som endast skrivs en gång, som t.ex. CD-ROM, DVD.

			[b]Blockindelad allokering[/b]
			Skivminnet delas in i lika stora block där det som håller koll på blocken kan vara en:
			[ul]
				[li]Länkad lista med pekare till nästa block.[/li]
				[li]Separat tabell med pekare till blocken som hålls i minnet. Även känt som File Allocation Table (FAT).[/li]
			[/ul][b]Indexerad allokering[/b]
			Här sparar vi information i en nod, även kallad en [i]i-nod[/i]. I en i-nod så sparar vi information om ägare, skapare, när filen skapades, rättigheter och vart datablocken finns på disk inklusive en räknare för antalet hårdalänkar, från början 1. Filnamnet sparas [i]ej[/i] i i-noden för en fil kan vara känd under flera namn och lagras därför i katalogen. Används i UNIX-system.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Vad för datastrukturer finns normalt sett i ett filsystem?
		</Question>
		<Answer>
			[b]På disk[/b]
			[ul]
				[li]Master Boot Record (en per disk) - Anger vilken som är den aktiva partitionen. Programmet som finns på MBR laddar in boot-blocket.[/li]
				[li]Boot block - Det första blocket, vilket är ett program som laddar in OS som finns på partitionen.[/li]
				[li]Superblock - Anger hur partitonen är indelad i block, vilka lediga block det finns osv.[/li]
				[li]File Control Blocks - i-noder.[/li]
				[li]Eventuella katalogstukturer.[/li]
			[/ul][b]I minne[/b]
			[ul]
				[li]Partitionstabell: Information on monterade partitioner.[/li]
				[li]Tabell med nyligen accesade kataloger.[/li]
				[li]Tabell över alla öppna filer med kopior av filernas File Control Block (FCB).[/li]
				[li]Per process-tabell för öppna filer.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Varför måste filer öppnas/stängas?
		</Question>
		<Answer>
			Öppna filen: För att kontrollera accessrätigheter.
			Stänga filen: Om filen buffrats i minne så behövs bufferten skrivas till disk.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Hur håller man ordning på lediga block på disken?
		</Question>
		<Answer>
			[ul]
				[li]Bitvektor (växer med diskstorleken och minskar med blockstorleken).[/li]
				[li]Länkade listor. Dessa kan byggas in i de lediga blocken, vilket inte kräver något extra utrymme (utom pekaren såklart).[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Vad är en mjuk och hård länk?
		</Question>
		<Answer>
			En [i]länk[/i] är en fil som innehåller sökvägen till en annan fil eller katalog. I UNIX så pekar en länk ut en i-nod.

			[b]Hård länk[/b]
			Hårda länkar som skapas av användare får endast peka ut filer (för att undvika cykler). När en hård länk skapas så uppdateras räknaren i den utpekade filens [b]i-nod[/b] som anger hur många som refererar till filen. En fil kan inte tas bort så länge denna räknare är större än 0. Det finns alltid minst en hård länk till varje fil/katalog.

			[b]Mjuk länk[/b]
			En mjuk länk får peka ut både filer och kataloger. En mjuk länk påverkar [i]ej[/i] räknaren i i-noden.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Ange olika typer av backups som kan göras på ett filsystem.
		</Question>
		<Answer>
			[b]Fysisk[/b]
			Skriver alla block i följd till mediumet som backup görs på.

			[b]Logisk (inkrementell)[/b]
			Skriver endast alla filer/kataloger som har ändrats till mediumet. I t.ex. UNIX så följs ej mjuka länkar när backup görs.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Ange olika typer av konsistenskontroller som kan göras på ett filsystem.
		</Question>
		<Answer>
			[b]Block-konsistens[/b]
			Kontrollerar att alla diskblock finns [b]en[/b] gång i antingen listan över fria block, i en fil eller i listan med dåliga block.

			[b]Filsystemskonsistens[/b]
			Kontrollerar att räknaren för hur många som refererar till en fil stämmer överens med hur många referenser som finns från katalogstrukturen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Vad för datastruktur har kärnan för öppna filer i ett UNIX-system?
		</Question>
		<Answer>
			För varje process så finns en tabell över fildeskriptorer. En fildeskriptor är ett heltal, som pekar ut en post i tabellen över öppna filer som delas av alla processer. För varje öppen fil kan det finnas flera poster av samma fil, men poster som har ärvts av en barnprocess av en föräldrarprocess delas. En post i tabellen innehåller position i filen, rättigheterna som filen är öppnad med och pekare till i-noden.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Vad innebär det att ett filsystem är journalförande?
		</Question>
		<Answer>
			Det innebär att filsystemet loggar ändringar i en journal före en skrivning till huvudfilsystemet. När skrivningen blivit klar så tas händelsen bort ifrån loggen. Detta gör om systemet kraschar när en skrivning sker så kan man undvika att filsystemet blir korrupt genom att t.ex. köra om skrivningarna.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Filsystem">
		<Question>
			Vad är det virtuella filsystemet (VFS) för något i UNIX?
		</Question>
		<Answer>
			Det virtuella filsystemet är en abstraktion som gör det möjligt att ha flera olika typer av filsystem (lokala och distribuerade) och partitioner. Det implementeras så att när en fil accessas identifieras den V-nod som pekar ut vilket filsystem filen ligger i.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Ange de två huvudklasserna av I/O-enheter.
		</Question>
		<Answer>
			[b]Block-devices[/b]
			Läser och skriver block-data. Typiska operationer är: read, write och seek. Exempel på enheter är hårddiskar och CD-ROM:ar.

			[b]Character-devices[/b]
			Skriver/läser en ström av tecken. Typiska operationer är: put och get. Exempel på enehter är tangentbord och nätverksenheter.

			Det finns andra enheter som t.ex. klockor som ej passar in i dessa klasser. Av effektivitetsskäl så brukar nätverksenheter implementeras med andra operationer.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Ange de två typer av I/O som kan utföras.
		</Question>
		<Answer>
			[b]Blockerande (synkron)[/b]
			Processen som begärt I/O väntar till dess att I/O-operationen är klar. Oftast är läsning blockerade.

			[b]Icke-blockerande (asynkron)[/b]
			Processen som begärt I/O väntar inte på att I/O-operationen ska bli klar. Oftast är skrivning icke-blockerande.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Ange olika sätt att styra I/O-enheter.
		</Question>
		<Answer>
			[b]Minnesmappad I/O[/b]
			Det innebär att kontroll- och dataregisters adresser ifrån enheten mappas in i den vanliga adressrymden. Det innebär att skrivning/läsning fungerar genom att en adress skrivs/läses.

			[b]Ports[/b]
			Varje I/O-enhet får ett portnummer. Kontrollregistret för enheten läses/skrivs med speciella I/O-instruktioner.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Ange olika sätt för att vänta på I/O ska bli klart.
		</Question>
		<Answer>
			[b]Programstyrd I/O (polling)[/b]
			I/O-enheten signalerar att den är klar genom att sätta en bit i ett av dess kontrollregister. Programmet som utfört I/O ligger sedan i en loop och läser av kontrollregistret för att upptäcka när I/O-enheten är klar. 

			Det är bra att använda när det behövs väntas kort tid på att enheten ska bli klar eller att det kostar för mycket att ha avbrott eller DMA. Nackdelen med denna metod är att det belastar CPU. Om minnesmappad I/O används så får ej sidan som innehåller adressen där kontrollregistret mappats in cachas, för då upptäcks inte att enheten blivit klar.

			[b]Avbrottstyrd I/O[/b]
			I/O-enheten signalerar att den är klar genom att generera ett avbrott. En avbrottsrutin fångar sedan upp avbrottet och kontrollerar eventuella fel och ser till att en eventuellt blockerad process som väntar på I/O hamnar i ready-kön. Nackdelen med avbrott är att det kostar att hantera på grund av att ett processbyte till avbrottshanteraren i kärnan krävs.

			[b]Direct Memory Access (DMA)[/b]
			Det innebär att en hårdvaruenhet kan överföra en mängd data till/från primärminnet och någon I/O-enhet (utan att behöva gå via CPUn). Ett avbrott generereras när överföringen är klar. Skillnaden emot avbrottstyrd är att där så genereras avbrott för varje block som överförs.	Vid läsning går datan som läses in först till kernel-space som sedan kopieras till processens adressrymd. Vid skrivning så kopieras data från processen till kernel-space. Onödig kopiering vid överföring kan undvikas genom att mappa om sidorna i sidtabellen.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Avbrott">
		<Question>
			Vad för regler finns det för vad en avbrottsrutin får göra?
		</Question>
		<Answer>
			[ul]
				[li]Får ej påverka processen som avbröts.[/li]
				[li]Måste bli klar snabbt.[/li]
				[li]Får ej vänta på något.[/li]
				[li]Kan inte bli blockerad.[/li]
				[li]Får inte generera sidfel.[/li]
				[li]Får inte utföra systemanrop.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Avbrott">
		<Question>
			Vad innebär precisa och icke-precisa avbrott?
		</Question>
		<Answer>
			[b]Precisa avbrott[/b]
			Hårdvaran sparar undan ett väldefinierat tillstånd då avbrottet inträffade.

			[b]Icke-precist avbrott[/b]
			Avbrottsrutinen får reda ut tillståndet som t.ex. eventuella halvt utförda instruktioner etc.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Vad är en drivrutin?
		</Question>
		<Answer>
			Det är något som ger ett enklare gränsnitt mot hårdvaran. OS:et måste även tillhandahålla ett väldefinierat gränssnitt mot drivrutinerna. En drivrutin anropas indirekt av systemanrop.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Vad innebär major och minor device number när det kommer till I/O-enheter i UNIX?
		</Question>
		<Answer>
			Major device number: identifierar drivrutinen som används.
			Minor device number: identifierar enheten om drivrutinen hanterar flera enheter.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Ange olika metoder för att schemalägga diskarmen.
		</Question>
		<Answer>
			[b]First Come First Serve (FCFS)[/b]
			Det innebär att diskarmen schemaläggs i samma ordning som förfrågningarna kommer in. Denna metod fungerar oftast inte så bra.

			[b]Shortest Seek First (SSF)[/b]
			Diskarmen schemaläggs så att den alltid tar den närmaste förfrågingen först, för att minimera söktiden (seek time). Ett problem med denna metod är att [i]svältning[/i] kan uppstå.

			[b]Elevator algorithm (SCAN)[/b]
			Diskarmen håller reda på vilken riktning som armen rör sig. Diskarmen läser sedan endast spår som ligger i samma riktning som armen rör sig, och tar dem i ordning, där den som är "närmast" i riktningen först. När armen har kommit till kanten/centrum så byter armen riktning.

			[b]LOOK[/b]
			Fungerar som SCAN algoritmen, men att den också kollar framåt i samma riktning för att se om det faktiskt finns några förfrågningar. Om så inte är fallet, så byter armen riktning.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Hur kan man åstadkomma "stable storage", dvs undviker att data förloras vid diskkrasch?
		</Question>
		<Answer>
			Det krävs att man har minst har två fysiska diskar, helst flera.
			[ul]
				[li]Alla skrivningar/läsningar går till alla diskarna.[/li]
				[li]Vid skrivning: Kontrollera att skrivingen lyckades för alla diskar.[/li]
				[li]Vid läsning: Kontrollera att alla läsningar lyckades och gav samma resultat.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Definera vad spår, sektorer och cylindrar är för något för en hårddisk.
		</Question>
		<Answer>
			Ett [b]spår[/b] är en del av skivan i hårddisken som roterar under ett läs/skrivhuvud. Om man har flera skivor så utgör alla spår för en given position för läs/skrivhvudet en [b]cylinder[/b]. Varje spår delas in i [i]block[/i] av samma storlek, vilket kallas för [b]sektorer[/b].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="IO">
		<Question>
			Vad är skillnaden mellan en fysisk och virtuell geometri för en hårddisk?
		</Question>
		<Answer>
			När man programmerar emot en hårddisk vill man för enkelhetens skull att varje spår har lika många sektorer. Men för en fysisk hårddisk är detta opraktiskt, för att spår som är närmare centrum vill man packa tätare, för att få bättre prestanda. En [b]virtuell geometri[/b] skapar då en abstraktion att alla spår har lika många sektorer, men på den [b]fysiska hårddisken[/b] så skiljer sig antalet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Vad är en tråd?
		</Question>
		<Answer>
			En tråd är en exekveringsväg genom en process och kan ses som en lättviktsprocess som delar adressrymd med de andra trådarna. En tråd innehåller bland annat:
			[ul]
				[li]Programräknare.[/li]
				[li]Register.[/li]
				[li]Stack.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Hur fungerar trådar som är implementerade i user-space?
		</Question>
		<Answer>
			Då är trådoperationerna biblioteksrutiner där trådarna schemaläggs av run-time-systemet. All hantering av trådar (skapande/dödande/terminande) sköts av biblioteksrutiner och av run-time-systemet.

			Fördelarna med trådar i user-space är att det krävs mindre context switches och att ett trådbyte kan ske utan systemanrop. Nackdelarna är att om en tråd blockeras så blockeras även hela processen (inklusive alla andra trådar i processen). Det går heller inte att uppnå sann parallellitet på multiprocesser och schemaläggningen är oftast icke-avbrytande (none-preemptive).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Hur fungerar trådar som är implementerade i kernel-space?
		</Question>
		<Answer>
			Då är trådoperationerna systemanrop där trådarna schemaläggs av kärnan. All trådhantering hanteras via systemanrop och av kärnan.

			Fördelarna med trådar i kernel-space är att de kan schemaläggas preemptivt. Om en tråd blockeras kan en annan tråd i samma process schemaläggas. Det går även att schemalägga olika trådar på olika processer för att uppnå sann parallellitet på multiprocesser. Nackdelarna är att trådoperationer är systemanrop som tar länge att utföra på grund av att context-switchar behövs göras.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Ange hur man kan kombinera trådar i user-space och i kernel-space.
		</Question>
		<Answer>
			Man kan t.ex. mappa flera trådar i user-space till en tråd i kernel-space.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Vad är en trådpool och varför vill man använda sig av det?
		</Question>
		<Answer>
			En [i]trådpool[/i] är en grupp av trådar som samverkar med varandra, där trådarna i väntan på förfrågningar ligger och sover. När en förfrågan kommer så väcks en tråd i poolen som behandlar förfrågan, innan den lägger sig och sover igen. Syftet med detta är att man vill undvika att skapa nya trådar för alla nya förfrågningar, eftersom det tar tid att skapa trådar.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Varför är det problematisk att utföra [i]fork[/i] och [i]exec[/i] i flertrådade system?
		</Question>
		<Answer>
			Det beror på att det finns två val när en tråd utför [i]fork[/i]:
			[ol]
				[li]Den nya processen får en tråd.[/li]
				[li]Den nya processen blir en exakt kopia av den gamla med lika många trådar.[/li]
			[/ol]När det kommer till [i]exec[/i] så är det vanligast att hela processen (dvs alla trådar) börjar exekvera det nya programmet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Vad innebär gängschemaläggning?
		</Question>
		<Answer>
			Det innebär att alla (eller så många som möjligt) trådar i en process kör samtidigt på olika CPU:er. Alla CPU:er byter också process samtidigt. Om en tråd blir blockerad så blir dess CPU idle så att inga andra trådar kan köras. Syftet med gängschemaläggning är att minimera tiden som trådarna behöver vänta på varandra om de kommunicerar/synkroniserar med varandra.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Hur kan man implementera lås på multiprocessorer?
		</Question>
		<Answer>
			Antag att [i]lock_ptr[/i] är adressen som vill låsa.
			
			Lås:
			[block]
lock: test_and_set	tmp, (lock_ptr)
      branch_not_zero	tmp, lock[/block]Lås upp:
      		[block]
unlock: store (lock_ptr), 0[/block]Där [i]test_and_set tmp (lock_ptr)[/i] är en maskininstruktion som:
      		[ul]
      			[li]Skriver värdet 1 till minnet på adress [i]lock_ptr[/i].[/li]
      			[li]Läser in gamla värdet till registret [i]tmp[/i].[/li]
      			[li]Låser bussen så att ingen annan processor kommer emellan.[/li]
      		[/ul]Denna typ av lås, där man hoppar tillbaka och försöker igen, kallas [i]spin-locks[/i]. Dessa lås är ej lämpliga för en-processormaskiner eftersom endast en annan process kan låsa upp låset (som ej kan köra samtidigt).
		</Answer>
	</TestQuestion>
	<TestQuestion Category="TrådarOchMultiprocessorer">
		<Question>
			Vad innebär falsk delning?
		</Question>
		<Answer>
			Det är när två olika CPU:er vill skriva till två olika variabler som ligger på samma sida/cache-linje, vilket innebär att båda cacherna måste tömas. Det händer oftare vid större sidor/cache-linjer och händer till en viss grad i alla cachar i multiprocessorer.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Vad är ett distribuerat system?
		</Question>
		<Answer>
			Det är ett system som består av ett antal datorer som är sammankopplade med nätverk som inte delar fysiskt minne och samverkar för att lösa ett problem, dvs fungerar som en enhet.

			Terminologi som används när man diskuterar distribuerade system är:
			[ul]
				[li][b]Site:[/b] Fysisk plats med en eller flera datorer.[/li]
				[li][b]Host:[/b] Dator på en site.[/li]
				[li][b]Server:[/b] Dator som har en resurs/tillhandahåller en tjänst som en annan dator vill använda.[/li]
				[li][b]Klient:[/b] Datorn som utnyttjar en tjänst hos en server.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Ange olika anledningar varför man vill ha ett distribuerat system.
		</Question>
		<Answer>
			[ul]
				[li]Resursdelning.[/li]
				[li]Uppsnabbning.[/li]
				[li]Tillförlitlighet.[/li]
				[li]Kommunikation.[/li]
				[li]Pris-prestanda.[/li]
				[li]Inkrementell uppdatering.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Vad innebär ett overlay network?
		</Question>
		<Answer>
			Det innebär att ett virtuellt nätverk/topologi implementeras i mjukvara ovanpå ett fysiskt nätverk.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Ange designmål när det kommer till distribuerade system.
		</Question>
		<Answer>
			[b]Transparens[/b]
			Att systemet är distribuerat inte syns för användaren. Det finns olika typer av transparens:
			[ul]
				[li]Namntransparens – namnet beror inte på var objektet finns.[/li]
				[li]Platstransparens (location transparency) – man behöver inte veta var resurser finns.[/li]
				[li]Flyttransparens – användaren märker inte om resurser flyttar.[/li]
				[li]Replikationstransparens – användaren behöver inte fundera på om man arbetar men en lokal kopia.[/li]
				[li]Samtidighetstransparens – man behöver inte veta om att någon annan använder resurser samtidigt.[/li]
				[li]Parallelitetstransparens – man behöver inte veta om att ens program körs parallellt.[/li]
			[/ul][b]Feltolerans[/b]
			[b]Skalbarhet[/b]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Att använda sig av caching i distribuerat filsystem är problematisk, varför?
		</Question>
		<Answer>
			Det är för att filen som cachas kan ha ändrats av andra. Om flera cachar finns, med olika innehåll, uppstår problem när man ska skriva till servern. Vilken version ska användas? Det finns olika sätt hantera det som:

			[b]Sekvensiell semantik (UNIX-semantik)[/b]
			Det innebär att det logiskt sett bara finns en kopia av varje fil. Denna semantik är svår att implementera effektivt.

			[b]Sessionssemantik[/b]
			Det innebär att varje klient som har filen öppen logiskt sett har en lokal kopia. Ändringar görs till den lokala kopian och när filen stängs så skrivs kopian tillbaka till servern. AFS implementerar på ett ungefär denna semantik.

			[b]Immutable (oförändlig)[/b]
			Det innebär att filer inte ändras, utan varje ny version ersätter den gamla. Varje version har ett nummer.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Ange olika cachekonsistensmekanismer för distribuerade system.
		</Question>
		<Answer>
			[ul]
				[li][b]Write-through:[/b] Varje skriving skrivs direkt till servern.[/li]
				[li][b]Delayed write:[/b] Ändringar skrivs periodvis. T.ex. efter 30 sekunder.[/li]
				[li][b]Write-on-close:[/b] Filen skrivs tillbaka när den stängs.[/li]
				[li][b]Centraliserad kontroll.[/b][/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Hur kan man implementera UNIX-semantik?
		</Question>
		<Answer>
			Varje klient får [i]tokens[/i] som ger rätt att använda en lokal kopia.
			[ul]
				[li]Flera klienter kan ha [i]lästokens[/i] till samma fil.[/li]
				[li]Om en klient har [i]skrivtoken[/i] till en fil får inga andra klienter ha några tokens till den filen.[/li]
				[li]Om man ej har token får man ej göra lokala operationer även om man har filen i cachen.[/li]
				[li]Det är servern som håller reda på alla tokens som delats ut.[/li]
			[/ul]Om en klient vill läsa en fil måste servern återkalla eventuellt utdelad skrivtoken:
			[ul]
				[li]Klient med skrivtoken ger ifrån sig detta tillsammans med alla nya data som den har skrivit.[/li]
				[li]Servern uppdaterar filen med dessa nya datan och skickar ändringarna/hela filen till klienten som ville läsa.[/li]
			[/ul]Om en klient vill skriva till en fil måste servern återkalla alla andra tokens.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Vad för för- och nackdelar finns det för filservar med och utan tillstånd?
		</Question>
		<Answer>
			[b]Med tillstånd[/b]
			Fördelar:
			[ul]
				[li]Kortare meddelanden från klienten.[/li]
				[li]Kan ge bättre prestanda.[/li]
				[li]Readahead möjligt.[/li]
				[li]Lättare att koordinera idempotenta operationer (ger samma resultat oberoende av antalet upprepningar).[/li]
				[li]Enklare att låsa filer.[/li]
			[/ul]Nackdelar:
			[ul]
				[li]Om klienten kraschar
					[ul]
						[li]Så kan filer bli öppna för evigt.[/li]
						[li]Tillståndsinformation ligger kvar på servern och kan ej tas bort (minnesläckor).[/li]
					[/ul]
				[/li]
				[li]
					Om servern kraschar
					[ul]
						[li]Information om t.ex. filoffset försviner för klienter med öppna filer.[/li]
						[li]Konsistensinformation (vilka klienter som har lokala kopior av filer) försvinner.[/li]
					[/ul]
				[/li]
			[/ul][b]Utan tillstånd[/b]
			Fördelar:
			[ul]
				[li]Feltolerans.[/li]
				[li]Att öppna/stänga filer behövs ej.[/li]
				[li]Kräver mindre minne för servern.[/li]
				[li]Inge begränsningar på antalet öppna filer.[/li]
				[li]Inga problem om klienten kraschar.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="DistribueradeSystem">
		<Question>
			Vad är konsistenssemantik när det kommer till distribuerade system?
		</Question>
		<Answer>
			Det beskriver hur man hanterar läsningar och skrivningar till en delad resurs. Om vi t.ex. har har ett distruberat filsystem så beskriver konsistenssemantiken beskriver i vilken  grad man kan förvänta sig att filsystemet är konsistent, t.ex. hur länge tid det kan dröja innan en uppdatering av en fil blir synliga för alla andra eller hur konflikter av uppdateringar av olika kopior hanteras.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Hur kan en pipe användas för synkronisering?
		</Question>
		<Answer>
			En pipe implementeras som en buffert i kärnan och har en fast storlek. Om en process vill skriva till en pipe vars buffert är full måste den vänta. Om en process vill läsa från en pipe vars buffert är tom måste den vänta. Detta är ett exempel på [i]synkronisering[/i].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad är en semafor?
		</Question>
		<Answer>
			En [i]semafor[/i] är en räknare som har operationerna:
			[ul]
				[li]Upp: Öka värdet med ett.[/li]
				[li]Ner: Minska värdet med ett om det ej är noll. Om så är fallet, vänta.[/li]
			[/ul] En semaforoperation är atomisk, dvs att ingen annan tråd eller process kan komma emellan.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad innebär ett race-condition?
		</Question>
		<Answer>
			Det innebär att två processer (eller trådar) tävlar om samma resurs.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad är en kritisk sektion?
		</Question>
		<Answer>
			Det är en sektion av kod där flera processer/trådar kan accessa och modifiera delad data eller delade resurser.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad är ett baklås (deadlock)?
		</Question>
		<Answer>
			Det innebär att en mängd processer [math]P[/math] så att varje [math]p in P[/math] väntar (är blockerad) på att någon händelse som endast kan orsakas av någon [math]p' in P[/math] körs. Orsaker till att någon process väntar är t.ex.:
			[ul]
				[li]I/O-enheter: [math]p[/math] vill ha skrivaren som [math]p'[/math] har reserverat.[/li]
				[li]Ömsesidig uteslutning: [math]p[/math] vill öppna en fil som [math]p'[/math] låst.[/li]
				[li]Andra resurser: [math]p[/math] vill starta en process men processtabellen är full.[/li]
				[li]Kommunikation: [math]p[/math] väntar på att [math]p'[/math] ska skicka ett meddelande.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad är Coffmans villkor (för baklås)?
		</Question>
		<Answer>
			[ul]
				[li]Ömsesidig uteslutning: Endast en process åt gången kan använda en resurs.[/li]
				[li]Behåll och vänta: En process kan behålla (reserverade) resurser medan den väntar på att få andra.[/li]
				[li]Ingen pre-emption (konfiskering): Resurser kan inte tas ifrån en process.[/li]
				[li]Cirkulär väntan: Det måste finnas en cykel av processer där varje process väntar på att få en resurs av nästa.[/li]
			[/ul]Resurser är saker som t.ex.: minne, diskenheter, lås, semaforer och meddelanden.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad innebär nödvändigt respektive tillräckligt villkor?
		</Question>
		<Answer>
			Ett [b]nödvändigt villkor[/b] [math]X[/math] för [math]A[/math] måste vara uppfyllt för att [math]A[/math] ska gälla, men att [math]X[/math] är uppfyllt betyder inte att [math]A[/math] gäller, dvs: [math]A \rightarrow X[/math].

			Ett [b]tillräckligt villkor[/b] [math]Y[/math] för [math]A[/math] är uppfyllt så gäller [math]A[/math]. Det omvända måste inte gälla, dvs att om inte [math]Y[/math] inte gäller så gäller inte [math]A[/math], dvs: [math]Y \rightarrow A[/math].

			En villkor kan antigen vara nödvändigt, tillräckligt eller båda och.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Är Coffmans villkor för baklås nödvändiga eller tillräckliga?
		</Question>
		<Answer>
			I det allmänna fallet är Coffmans villkor nödvändiga för att baklås ska uppstå. Detta innebär om vi bryter ett av villkoren så kan inte baklås uppstå. För speciallfallet då det endast finns en enhet av varje resurstyp så är Coffmans villkor både nödvändiga och tillräckliga. Detta innebär om Coffmans villkor är uppfyllda har vi också ett baklås.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad kan man göra för att hantera baklås?
		</Question>
		<Answer>
			[b]Gör ingenting (strutsalgoritmen)[/b]
			Anledingen för detta är att det är dyrt och krångligt att undvika/upptäcka baklås. Används i bland annat Unix.

			[b]Detektering och återhämtning[/b]
			Systemet håller reda på resursallokering och letar efter cykler. Används i VMS.

			[b]Undvikande genom försiktighet[/b]
			Kräver begräsningar för användarprocesser.

			[b]Förhindrade genom elimination av nödvändigt villkor[/b]
			Kan inte alltid genomföras fullt ut, men kan användas för att eliminera vissa källor till baklås.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Hur kan man upptäcka baklås?
		</Question>
		<Answer>
			[b]Om det bara finns en enhet av varje resurs[/b]
			Då är det ganska enkelt att implementera. Systemet håller reda på för varje process vilka resurser den har och vilka den väntar på. Om det finns cykler, så kan baklås existera. Det finns algoritmer som kan hitta cykler i linjär tid.

			[b]Om det finns fler av varje resurs[/b]
			Då blir det mycket mer komplicerat. En process som väntar på att få en resurs väntar på någon av de processer som har resursen ska släppa den. Den cirkulära väntan kan komma att brytas av att processer som är klara med användingen av en resurs släpper sina resurser. En lösning är att konstruera Bankiralgoritm-tabeller.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Hur kan man återhämta sig ifrån baklås?
		</Question>
		<Answer>
			[b]Inför pre-emption (konfiskation)[/b]
			Det innebär att man tar ifrån en process en resurs. T.ex. för fysisk minne kan man göra en page-out. 

			[b]Roll-back (tillbakarullning)[/b]
			Det innebär att man går tillbaka till en tidigare punkt i exekveringen och väljer en annan schemaläggning. Vissa operationer som har sidoeffekter, t.ex. I/O, är problematiskt att rulla tillbaka.

			[b]Döda processer[/b]
			Någon av de låsta processerna slås hjäl. Detta garanterar ej att baklåset låses upp direkt, men om man fortsätter att slå ihjäl processer så kommer det till slut att låsas upp.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Hur fungerar Bankiralgoritmen?
		</Question>
		<Answer>
			Det bygger på att systemet kan kontrollera schemaläggningen av processerna. Varje process måste anmäla sitt maximala resursbehov i förväg. Systemet ska alltid befinna sig i ett säkert tillstånd, vilket definieras som: Det finns en ordning i vilken processerna kan köras som inte leder till låsning även om alla processer utnyttjar hela sitt maximala resursbehov. Om en process kommer med en begäran som skulle leda till att systemet hamnar i ett osäkert tillstånd så körs en annan process istället. Den uppskjutna begäran uppfylls senare.

			Algoritmen går oftast inte att använda eftersom en process sällan känner till hela sitt resursbehov innan programmet börjar exekvera.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad kan man göra för att förhinda baklås?
		</Question>
		<Answer>
			Se till att något av Coffmans fyra villkor inte gäller.
			[ul]
				[li]Ej tillåta att en processer äger en resurs exklusivt utan alla resurser ska kunna delas. I de flesta faller går det inte att göra men i vissa fall, t.ex. med skrivare, går det där man låter en process fungera som resurshanterare.[/li]
				[li]Behåll och vänta: Kräv att en process släpper alla resurser när den begär en ny eller att den begär alla resurser på samma gång.[/li]
				[li]Ingen konfiskering: Vissa resurser kan konfiskeras som t.ex. fysiskt minne och processorn (om avbrytande schemaläggning används).[/li]
				[li]Cirkulär väntan: Ge alla resurser ett nummer. Det är bara tillåtet att allokera resurser i en ökande ordning. En av de mest populära villkoren som man försöker ge sig på.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Antag att man har lås för flera kritiska sektioner och flera processer använder flera av de kritiska sektionerna. Vad bör man då göra?
		</Question>
		<Answer>
			Att man låser sektionerna i samma ordning, detta undvilker att baklås uppstår.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Vad innebär livelock?
		</Question>
		<Answer>
			Det innebär att en grupp av processer som exekverar inte kommer vidare eftersom de hela tiden synkroniserar med varandra. Detta är svårt att upptäcka eftersom procsserna fortfarnade exekverar.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Synkronisering">
		<Question>
			Hur fungerar logiska klockor?
		</Question>
		<Answer>
			[ul]
				[li]Varje process [math]i[/math] har en egen logisk klocka [math]T_i[/math].[/li]
				[li]Vid varje lokal händelse i processen så sätts [math]T_i = T_i + 1[/math].[/li]
				[li]När ett meddelande skickas till en annan process så uppdateras [math]T_i[/math] och skickas med meddelandet.[/li]
				[li]När ett meddelande tas emot så uppdateras den lokala tiden till [math]max(text{lokaltid}+1, text{meddelandetid}+1)[/math][/li]	
			[/ul]Detta ger en kausal ordning, dvs om en händelse [math]A[/math] orskat en händelse [math]B[/math] (direkt eller indirekt) så är tidsstämpeln för [math]A[/math] mindre än tidsstämpeln för [math]B[/math].

			En total ordning av händelser kan uppnås om man t.ex. använder ett (unikt) ID för processer för att ordna händelser med samma tidsstämpel.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Hur fungerar inloggning av användare med lösenord i UNIX?
		</Question>
		<Answer>
			Lösenordet används som nyckel för att kryptera ett fixt datablock där datablocket är samma för alla användare. Lösenordsfilen består av par av (användarnamn, krypterat datablock). Vid inloggning så letar man fram användarnamnet och kontrollerar att det krypterade datablocket i lösenordsfilen är identiskt med det som genererades vid inloggningen genom krypteringen med det lösenord som användaren gav.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Ange olika kryptosystem.
		</Question>
		<Answer>
			[b]Symmetrisk[/b]
			Då är både krypterings- och dekrypteringsnycklarna samma. Används ofta för t.ex. diskkryptering och exempel på algoritmer är: AES.

			[b]Assymetrisk (publik-nyckel)[/b]
			Då är krypterings- och dekrypteringsnycklarna olika. Systemet brukar fungera så att en nyckel publiceras, den publika och en nyckel hålls hemliga, den privata. Systemet bör även ha egenskapen att det ska vara mycket svårt att givet den publika nyckeln få fram den privata nyckeln. Exempel är RSA systemet.

			[b]Envägsfunktioner[/b]
			Givet ett [math]y[/math] värde och en funktion [math]f[/math] så att: [math]y=f(x)[/math] så är det mycket svårt att beräkna [math]x[/math] givet ett [math]y[/math]. Ett alternativt namn är en [i]hash funktion[/i].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Hur fungerar en digital signatur?
		</Question>
		<Answer>
			Det används för att signera och därmed kunna autentisera dokument. Det fungerar på följande sätt: Antag att vi har att publik-nyckel krypteringssystem där [math]D(E(x))=x[/math].

			[b]Signering[/b]
			[ol]
				[li]Beräkna ett hash-värde [math]H[/math] för dokumentet med en hash algoritm som t.ex. SHA2.[/li]
				[li]Skaparen av dokumentet signerar dokumentet genom att kryptera [math]H[/math] med sin privata nyckel, [math]S=E(H)[/math].[/li]
			[/ol][b]Autenticering[/b]
			[ol]
				[li]Beräkna hash-värdet för [math]H'[/math] för dokumentet utan signaturen.[/li]
				[li]Dekryptera signaturen med den publika nyckeln, [math]H=D(S)[/math].[/li]
				[li]Om [math]H = H'[/math] så vet vi att signaturen är autentisk.[/li]
			[/ol]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad kan man göra för att göra det svårare för inkräktare att testa användarnamn/lösenord?
		</Question>
		<Answer>
			[ul]
				[li]Inte visa hur många tecken som matas in för lösenordet vid inloggning.[/li]
				[li]Skicka [i]aldrig[/i] användarnamn/lösenord i klartext över ett nät som kan avlyssnas av andra.[/li]
				[li]Att inloggningen inte avbryts även om det användarnamnet som matades in inte existerade.[/li]
				[li]Begränsa antalet inloggningsförsök som kan göras eller efter varje inloggningsförsök som görs så måste användaren vänta tills nästa försök kan göras. Här används ofta "exponentiell back-off" som innebär att vi multiplicerar väntetiden med någon bas. t.ex. 2 efter varje försök.[/li]
				[li]Logga alla inloggningsförsök som kan göras, lyckade och misslyckades för att kunna identifiera attacker.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad är en trojansk häst?
		</Question>
		<Answer>
			Det är ett program med två mål, där det ena är uppenbart för användaren och det andra är gömt för användaren. Trojanska hästar kan antingen byggas från existerande program eller byggas från början för att vara en trojansk häst. 
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad är en bakdörr (backdoor)?
		</Question>
		<Answer>
			Det är ett program (eller del av program) som ger tillgång till ett system. En bakdörr behöver inte vara skapad för att skada utan kan vara en del av supporten för programmet eller finnas där av andra legitima anledningar. Bakdörrar brukar typiskt vara mycket svåra att hitta.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad är en logisk bomb för något?
		</Question>
		<Answer>
			Det är en bit kod som en anfallare infogar i ett program som inte körs förrän ett specifikt villkor är uppfyllt.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad är ett virus för något?
		</Question>
		<Answer>
			Ett virus är ett program som infekterar andra progrm. När programmet körs så försöker viruset replikera sig till andra program. Virus är ofta specifika till operativsystem och hårdvara och tar vara på brister.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Ange olika typer av virus.
		</Question>
		<Answer>
			[b]Kompanjonvirus[/b]
			Ett annat program körs istället för det program som användare ville köra, ingen kod infekteras.

			[b]Minnesresidenta virus[/b]
			Ett virus som lägger sig resident i minnet och nästlar ofast in i kärnan och brukar t.ex. ta kontroll över TRAP eller avbrottsvektorn. Genom att viruset är i kärnan, kan den övervaka varje systemanrop som utförs.

			[b]Bootsektor virus[/b]
			Viruset kopierar bootsektorn till en ledig sektor och skriver in sig själv på bootsektorn. Viruset kommer då att startas varje gång datorn bootas för att BIOS exekeverar det som ligger på bootsektorn.

			[b]Drivurtinsvirus[/b]
			Sprids genom infekterade drivrutiner, som installeras av användaren. Detta gör att viruset kan köra i kärnan.

			[b]Markovirus[/b]
			Viruset ligger som makron i t.ex. Word eller Excel-dokument.

			[b]Källkodsvirus[/b]
			Infekterar källkodsfiler.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad är en mask (worm) för något?
		</Question>
		<Answer>
			Ett replikerande program som sprider sig själv över ett nätverk som beter sig likt ett virus med liknande faser.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad är ett rootkit för något?
		</Question>
		<Answer>
			Det är ett skadligt program som som installeras på ett system med root/administratör-rättigheter. Ett rootkit kan t.ex. byta ut systemanrop mot sina egna vilket kan bli mycket skadligt.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad är "buffer overflow" för något?
		</Question>
		<Answer>
			Det är när mer data försöker sparas än vad som får plats i en buffert av fixt storlek, vilket gör att data som ligger efter i minnet skrivs över. Med hjälp av denna attack kan man få ett program att krasha eller få programmet att utföra instruktioner som anfallaren vill.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad kan ett virus göra för att undvika att bli upptäckt?
		</Question>
		<Answer>
			[b]Polymorphism[/b]
			Ett virus som muterar sig efter varje infektion, vilket gör att det inte finns någon signatur.

			[b]Metamorphism[/b]
			Fungerar som ett polymorfiskt virus, men vid varje infektion så skriver viruset om sig helt vilket gör det ännu svårare att upptäcka.

			[b]Komprimering[/b]
			Den komprimerar filen som infekteras och lägger till sig själv till filen. Detta gör att den infekterade filen får samma storlek som originalfilen.

			[b]Kryptering[/b]
			En del av viruset skapar en slumpmässig krypteringsnyckel och krypterar resterande del av viruset. Nyckeln lagras sedan i viruset. När ett infekterat program körs så använder viruset nyckeln för att dekryptera resterande del av viruset. Eftersom den största delen av viruset är krypterad med en slumpmässig nyckel finns det ingen signatur att upptäcka.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad kan man göra för att undvika virus?
		</Question>
		<Answer>
			[ul]
				[li]Välj ett OS med hög inbyggd säkerhet.[/li]
				[li]Uppdatera koninuerligt OS med patchar som täpper till säkerhetshållen.[/li]
				[li]Installera endast programvara från pålitliga källor.[/li]
				[li]Installera ett bra antivirusprogram.[/li]
				[li]Öppna inte bifogade filer i emails.[/li]
				[li]Gör regelbudna incrementella backuper och spara backuper över lång tid.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Hur fungerar virus scanners?
		</Question>
		<Answer>
			De fungerar genom att leta efter kända virus och kod som liknar virus genom att använda sig av databaser med virussignaturer. 
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Hur fungerar Integritetskontroll (för att upptäcka virus)?
		</Question>
		<Answer>
			Det beräknar först en checksumma för varje virusfri fil som sedan krypteras och sparas fil. När en programmet sedan exekveras så beräknas checksumman igen och jämförs emot den sparade. Om checksumman är samma är det hög sannolikhet att programmet är virusfri.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Hur fungerar beteendekontroll (för att upptäcka virus)?
		</Question>
		<Answer>
			Den fångar upp alla systemanrop och försöker upptäcka om något misstänksamt pågår.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Vad är "sandboxing" och fungerar det?
		</Question>
		<Answer>
			Det är sätt för att undvika att program utför dåliga saker på datorn. Det fungerar så att programmet körs i en "sandlåda" där alla potentiellt farliga operationer (typ systemanrop) kontrolleras och är isolerade från systemet.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Se Datasäkerhetstentan för mer information om säkert.
		</Question>
		<Answer>
			[url="http://tenta.antjans.se/TestGenerator/ViewTest?course=Datas%C3%A4kerhet&amp;test=DasakTenta&amp;numQuestions=82&amp;noneRandom=True"]Länk[/url].
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Säkerhet">
		<Question>
			Varför bör man ej ha med "." i sin PATH miljövariabler i UNIX?
		</Question>
		<Answer>
			Vanligtvist om man vill starta program som ligger i samma katalog så anropar man "./namn_på_programmet". Om man lägger till "." i sin PATH miljövariabel så behövs ej "./" utan då kan man starta ett program direkt genom att endast ange dess namn.

			Detta ger dock sämre säkerhet. Antag att vi har ett program "ls" (som är t.ex. en trojansk häst) i den nuvarande katalogen. Om vi har "." i vår miljövariabel (och den ligger före /usr/bin eller där ls ligger) så kommer programmet i den nuvarande programmet att köras, inte det riktiga ls.

			Om vi inte har "." i PATH, så går det ej att starta programmet utan "./" i början. Detta innebär om vi aldrig skriver in "./" så kan vara säkra på att vi alltid kommer köra ett pålitligt program.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Hur fungerar schemaläggning i UNIX?
		</Question>
		<Answer>
			Det finns två nivåer av schemaläggning:
			[ul]
				[li]Lågnivå: Välj nästa process som ska exekevera av de som finns i minnet.[/li]
				[li]Högnivå: Flytta processer till/från minnet (swapping).[/li]
			[/ul][b]Lågnivå schemaläggning[/b]
			[ul]
				[li]Prioriteter: -20 – 20[/li]
				[li]Procsser som körs i användarläge har positiva prioriteter, kernel negativa.[/li]
				[li]Det finns en kö för varje prioritet där round-robin används inom varje kö.[/li]
				[li]En process kör sin tidskvanta (ca 100 ms) eller till dess att den blockerar.[/li]
				[li]En gång per sekund så beräknas alla procssers prioriteter om enligt formeln: [math]text{prioritet}=text{CPU-använding}+text{nice}+text{basprioritet}[/math].[/li]
				[li]De processer som använt en stor del av sin tidskvanta får sin prioritet [i]temporärt[/i] sänkt.[/li]
			[/ul]Schemaläggningen är optimerad för interaktiva processer, dvs processer med mycket I/O.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Hur fungerar schemaläggning i Linux?
		</Question>
		<Answer>
			I Linux så schemaläggs trådar, inte processer. Det finns tre klasser av schemaläggningen: "Real-Time" FIFO, "Real-Time" round-robin (kan avbrytas av klockan) och timesharing. Prioriteten går ifrån 0-40 där prioriteten beräknas som: Grundprioritet + nice.

			Alla processer har individuella tidskvanta. Schemaläggningen baseras på "goodness" som beräknas för varje process vid varje schemaläggningstillfälle. Den beräknas enligt:
			[i]Om den nuvarande klassen är realtid:[/i] [math]text{goodness} = 1000 + text{priority}[/math].
			[i]Om tidskvatan inte är slut:[/i] [math]text{goodness} = text{quantum} + text{priority}[/math].
			[i]Annars (dvs tidskvatan är slut)[/i]: [math]text{goodness} = 0[/math].

			[b]Schemaläggningsalgoritmen fungerar på följande sätt:[/b]
			CPUn tas från en tråd då:[ul]
				[li]Den har förbrukat sitt tidskvanta.[/li]
				[li]Den blockeras av t.ex. I/O eller synkronisering.[/li]
				[li]En tråd med högre goodness blir körklar.[/li]
			[/ul]När det inte längre finns några körbara processer (alla är blockerade eller har tidskvanta = 0) så beräknas tidskvanta enligt: [math]text{quantum}=text{quantum}/2+text{priority}[/math].

			Schemaläggningen har följande egenskaper: Ger företräde åt I/O-bundna processer och CPU-bundna processer får CPU-tid i förhållande till sina prioriteter. När flera processorkärnor används så sker lastbalansering var 200 ms mellan kärnorna och det finns möjlighet att ange vilken kärna som procesen får exekvera på.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Hur fungerar schemaläggning i Windows?
		</Question>
		<Answer>
			I Windows så schemaläggs trådar, inte processer. Ett högt numeriskt värde på prioriteten ger hög prioritet. Det finns 7 grundklasser för trådar (grundprioriteter) och 6 nivåer inom varje klass. Detta ger att prioriteten blir: [math]text{basprioritet}_1 - 42[/math]

			Schemaläggningskoden körs:
			Av en tråd om:
			[ul]
				[li]Tråden blockeras för I/O eller synkronisering.[/li]
				[li]Tråden signalerar till ett objekt (t.ex. upp på en semafor).[/li]
				[li]Trådens tidskvanta tar slut.[/li]
			[/ul]Av andra delar om:
			[ul]
				[li]En I/O-operation blir klar.[/li]
				[li]En tidsbegränsad [i]wait[/i] blir klar.[/li]
			[/ul]Den tråd som ska schemaläggas baseras på nuvarande prioritet som kan vara högre än basprioriteten, upp till 15 där den normala basprioriteten är ca 8. Prioriteten kan höjas under en period tills dess att tidkvanta tar slut, vid följande tillfällen:
			[ul]
				[li]I/O blir klar: disk ger +1, serieport +2, tangentbord +6 och ljudkort +8.[/li]
				[li]När en händelse sker (väntan på semafor, lås, etc) vilket för förgrundsprocesser ger +2 och för andra processer +1.[/li]
			[/ul]Schemaläggningen är självjusterade men administratören kan finjustera många parametrar. Den är optimerad för interaktivitet i Professional-utgåvorna och för throughput i serverutgåvorna. När flera processorkärnor används så försöker tråden schemalägga på samma CPU för att återanvända cacheinnehåll.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Hur hanteras det virtuella minnet i Windows?
		</Question>
		<Answer>
			Det är indelat i sidor, som normalt är 4 KB stora. Windows använder sig av ren demand paging (ingen pre-pagning.) En sida kan vara i tre tillstånd:
			[ul]
				[li]Free: Används inte (alla sidor är free från början).[/li]
				[li]Committed: Sidan är mappad att innehålla data eller kod.[/li]
				[li]Reserved: Sidan är reserverad och får inte användas om inte reservationen hävs. Kan t.ex. användas för att reservera utrymme på stacken.[/li]
			[/ul] Det virtuella minnet kan delas in i icke-konsekutiva regioner.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Hur fungerar delat minne i Windows?
		</Question>
		<Answer>
			Processer kan mappa filer/minnesareor så att de kan delas. Vid skrivning till en minnesmappad fil/delad minnesarea så kan följande hända:
			[ul]
				[li]Om alla processer som delar arean tillåter skrivning så sker skrivningen till den delade arean.[/li]
				[li]Om någon process bara tillåter läsning skapas en kopia då skrivningen sker (copy-on-write).[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			När kan det uppstå sidfel i Windows?
		</Question>
		<Answer>
			[ol]
				[li]Sidan är inte "commited" [math]\rightarrow[/math] fatalt fel.[/li]
				[li]"Protection violation" [math]\rightarrow[/math] fatalt fel.[/li]
				[li]En delad sida skrivs, kan resultera i "copy-on-write".[/li]
				[li]Stacken behöver utökas, en ny [i]nollställd[/i] ram allokeras.[/li]
				[li]En "committed" ram behöver mappas in [math]~~[/math] vanligt sidfel.[/li]
			[/ol]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Hur fungerar sidutbytesalgoritmen i Windows?
		</Question>
		<Answer>
			Det är en lokal sidutbytesalgoritm som används, som baseras på working set. Per process så finns minimalt 20-50 ramar och maximalt 45-345 ramar. Gränserna kan temporärt under- eller överskridas. Minst 512 lediga ramar skall finnas för nya processer.

			Det finns även en global algoritm som består av:
			[ul]
				[li]En kärntråd ("balance set manager") som kontrollerar att det finns tillräckligt många lediga ramar globalt sett, annars startas "working set manager".[/li]
				[li]Working set manager: Tar (baserat på en heuristik) ramar från först: icke-aktiva processer, stora processer, processer med fler ramar än minimalt antal och föregrundsprocesser.[/li]
				[li]Den kan även justera antalet ramar till under det minimala antalet ramar för processen.[/li]
			[/ul]
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Hur sker fördelningen av adressrymden i 32-bitars Windows?
		</Question>
		<Answer>
			En process adressrymd är 4 GB, där 2 GB mappas in till operativsystemet och resten får processen. Syftet med att mappa in OS är att det blir snabbare att gå från användarläge till kärnläge.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Ange olika termer som används när man diskuterar processer i Windows.
		</Question>
		<Answer>
			[b]Process[/b]
			En behållare som har resurser knutna till sig som t.ex. minne och en eller flera trådar.

			[b]Tråd[/b]
			En enhet som schemaläggs av CPUn.

			[b]Jobb[/b]
			Det är uppsättning processer som hanteras som en enhet med gemensam gräns för resursutnjyttjande.

			[b]Fiber[/b]
			En lättviktsprocess som implementeras i användarläge.
		</Answer>
	</TestQuestion>
	<TestQuestion Category="Fallstudie">
		<Question>
			Hur fungerar filer i Windows?
		</Question>
		<Answer>
			En fil i Windows består av attributer och flera strömmar av bytes. Varje ström kan hantera olika typer av data, som t.ex. video och ljud. En fil kan automatisk komprimeras/dekomprimeras då de skrivs/läses till/från disk. Komprimeringen fungerar så om den komprimerade datan kan skrivs på 15 eller mindre block så sker komprimeringen, om komprimeringen fortfarande tar 16 blocks så undviker man att komprimera datan.
		</Answer>
	</TestQuestion>
</Test>
